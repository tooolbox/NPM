// Code generated by go-swagger; DO NOT EDIT.

package account_maintenance

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/tooolbox/firstvision/models"
)

// PricingControlUpdateV1FvEmeaReader is a Reader for the PricingControlUpdateV1FvEmea structure.
type PricingControlUpdateV1FvEmeaReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PricingControlUpdateV1FvEmeaReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewPricingControlUpdateV1FvEmeaOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPricingControlUpdateV1FvEmeaBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewPricingControlUpdateV1FvEmeaUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPricingControlUpdateV1FvEmeaForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewPricingControlUpdateV1FvEmeaNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewPricingControlUpdateV1FvEmeaTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 452:
		result := NewPricingControlUpdateV1FvEmeaStatus452()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 453:
		result := NewPricingControlUpdateV1FvEmeaStatus453()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 455:
		result := NewPricingControlUpdateV1FvEmeaStatus455()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 465:
		result := NewPricingControlUpdateV1FvEmeaStatus465()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewPricingControlUpdateV1FvEmeaOK creates a PricingControlUpdateV1FvEmeaOK with default headers values
func NewPricingControlUpdateV1FvEmeaOK() *PricingControlUpdateV1FvEmeaOK {
	return &PricingControlUpdateV1FvEmeaOK{}
}

/*PricingControlUpdateV1FvEmeaOK handles this case with default header values.

successful operation
*/
type PricingControlUpdateV1FvEmeaOK struct {
	Payload *models.PricingControlUpdateResponse
}

func (o *PricingControlUpdateV1FvEmeaOK) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaOK  %+v", 200, o.Payload)
}

func (o *PricingControlUpdateV1FvEmeaOK) GetPayload() *models.PricingControlUpdateResponse {
	return o.Payload
}

func (o *PricingControlUpdateV1FvEmeaOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.PricingControlUpdateResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPricingControlUpdateV1FvEmeaBadRequest creates a PricingControlUpdateV1FvEmeaBadRequest with default headers values
func NewPricingControlUpdateV1FvEmeaBadRequest() *PricingControlUpdateV1FvEmeaBadRequest {
	return &PricingControlUpdateV1FvEmeaBadRequest{}
}

/*PricingControlUpdateV1FvEmeaBadRequest handles this case with default header values.

Below are the error codes you can expect when connecting over internet:<BR/><BR/>API-Sec-003 - Invalid request. This could be because of invalid data in the request or header, among other reasons.<BR/>API-Sec-004 - Invalid request. The client_assertion JWT is invalid<BR/>API-Sec-013 - The JWT has an invalid expiry. Pleases end a request with a valid JWT
*/
type PricingControlUpdateV1FvEmeaBadRequest struct {
	Payload *models.FsErrorDetails
}

func (o *PricingControlUpdateV1FvEmeaBadRequest) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaBadRequest  %+v", 400, o.Payload)
}

func (o *PricingControlUpdateV1FvEmeaBadRequest) GetPayload() *models.FsErrorDetails {
	return o.Payload
}

func (o *PricingControlUpdateV1FvEmeaBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.FsErrorDetails)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPricingControlUpdateV1FvEmeaUnauthorized creates a PricingControlUpdateV1FvEmeaUnauthorized with default headers values
func NewPricingControlUpdateV1FvEmeaUnauthorized() *PricingControlUpdateV1FvEmeaUnauthorized {
	return &PricingControlUpdateV1FvEmeaUnauthorized{}
}

/*PricingControlUpdateV1FvEmeaUnauthorized handles this case with default header values.

Unauthorized: Authorization failed due to missing or invalid credentials. <BR/>Below are the error codes you can expect when connecting over internet:<BR/><BR/>API-Sec-001 - The auth header has invalid values. Please try with valid values<BR/>API-Sec-002 - The client id provided is invalid. Please try with valid client id<BR/>API-Sec-007 - The access token is invalid. It may have expired, or maybe incorrect
*/
type PricingControlUpdateV1FvEmeaUnauthorized struct {
	Payload *models.FsErrorDetails
}

func (o *PricingControlUpdateV1FvEmeaUnauthorized) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaUnauthorized  %+v", 401, o.Payload)
}

func (o *PricingControlUpdateV1FvEmeaUnauthorized) GetPayload() *models.FsErrorDetails {
	return o.Payload
}

func (o *PricingControlUpdateV1FvEmeaUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.FsErrorDetails)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPricingControlUpdateV1FvEmeaForbidden creates a PricingControlUpdateV1FvEmeaForbidden with default headers values
func NewPricingControlUpdateV1FvEmeaForbidden() *PricingControlUpdateV1FvEmeaForbidden {
	return &PricingControlUpdateV1FvEmeaForbidden{}
}

/*PricingControlUpdateV1FvEmeaForbidden handles this case with default header values.

Forbidden: Insufficient access for requested operation. <BR/>Below are the error codes you can expect when connecting over internet:<BR/><BR/>API-Sec-006 - Replay attack detected. Please try again with valid data<BR/>API-Sec-008 - Mismatch in scope. The access token does not have the permission to access this resource
*/
type PricingControlUpdateV1FvEmeaForbidden struct {
	Payload *models.FsErrorDetails
}

func (o *PricingControlUpdateV1FvEmeaForbidden) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaForbidden  %+v", 403, o.Payload)
}

func (o *PricingControlUpdateV1FvEmeaForbidden) GetPayload() *models.FsErrorDetails {
	return o.Payload
}

func (o *PricingControlUpdateV1FvEmeaForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.FsErrorDetails)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPricingControlUpdateV1FvEmeaNotFound creates a PricingControlUpdateV1FvEmeaNotFound with default headers values
func NewPricingControlUpdateV1FvEmeaNotFound() *PricingControlUpdateV1FvEmeaNotFound {
	return &PricingControlUpdateV1FvEmeaNotFound{}
}

/*PricingControlUpdateV1FvEmeaNotFound handles this case with default header values.

Below are the error codes you can expect when connecting over internet:<BR/><BR/>API-Sec-005 - Resource not found
*/
type PricingControlUpdateV1FvEmeaNotFound struct {
	Payload *models.FsErrorDetails
}

func (o *PricingControlUpdateV1FvEmeaNotFound) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaNotFound  %+v", 404, o.Payload)
}

func (o *PricingControlUpdateV1FvEmeaNotFound) GetPayload() *models.FsErrorDetails {
	return o.Payload
}

func (o *PricingControlUpdateV1FvEmeaNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.FsErrorDetails)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPricingControlUpdateV1FvEmeaTooManyRequests creates a PricingControlUpdateV1FvEmeaTooManyRequests with default headers values
func NewPricingControlUpdateV1FvEmeaTooManyRequests() *PricingControlUpdateV1FvEmeaTooManyRequests {
	return &PricingControlUpdateV1FvEmeaTooManyRequests{}
}

/*PricingControlUpdateV1FvEmeaTooManyRequests handles this case with default header values.

Below are the error codes you can expect when connecting over internet:<BR/><BR/>API-Sec-009 - You have exceeded the App level quota<BR/>API-Sec-010 - You have exceeded the Developer level quota<BR/>API-Sec-011 - You have exceeded the Product level quota<BR/>API-Sec-012 - Too many requests for this API. Please try after sometime
*/
type PricingControlUpdateV1FvEmeaTooManyRequests struct {
	Payload *models.FsErrorDetails
}

func (o *PricingControlUpdateV1FvEmeaTooManyRequests) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaTooManyRequests  %+v", 429, o.Payload)
}

func (o *PricingControlUpdateV1FvEmeaTooManyRequests) GetPayload() *models.FsErrorDetails {
	return o.Payload
}

func (o *PricingControlUpdateV1FvEmeaTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.FsErrorDetails)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPricingControlUpdateV1FvEmeaStatus452 creates a PricingControlUpdateV1FvEmeaStatus452 with default headers values
func NewPricingControlUpdateV1FvEmeaStatus452() *PricingControlUpdateV1FvEmeaStatus452 {
	return &PricingControlUpdateV1FvEmeaStatus452{}
}

/*PricingControlUpdateV1FvEmeaStatus452 handles this case with default header values.

System Exception: Internal processes not related to client interaction with application are the cause of the failure
*/
type PricingControlUpdateV1FvEmeaStatus452 struct {
}

func (o *PricingControlUpdateV1FvEmeaStatus452) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaStatus452 ", 452)
}

func (o *PricingControlUpdateV1FvEmeaStatus452) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPricingControlUpdateV1FvEmeaStatus453 creates a PricingControlUpdateV1FvEmeaStatus453 with default headers values
func NewPricingControlUpdateV1FvEmeaStatus453() *PricingControlUpdateV1FvEmeaStatus453 {
	return &PricingControlUpdateV1FvEmeaStatus453{}
}

/*PricingControlUpdateV1FvEmeaStatus453 handles this case with default header values.

Validation Exception: The request failed validation, modify the request and resubmit
*/
type PricingControlUpdateV1FvEmeaStatus453 struct {
}

func (o *PricingControlUpdateV1FvEmeaStatus453) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaStatus453 ", 453)
}

func (o *PricingControlUpdateV1FvEmeaStatus453) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPricingControlUpdateV1FvEmeaStatus455 creates a PricingControlUpdateV1FvEmeaStatus455 with default headers values
func NewPricingControlUpdateV1FvEmeaStatus455() *PricingControlUpdateV1FvEmeaStatus455 {
	return &PricingControlUpdateV1FvEmeaStatus455{}
}

/*PricingControlUpdateV1FvEmeaStatus455 handles this case with default header values.

ODS Error Exception: ODS returned a message with transaction status ERROR
*/
type PricingControlUpdateV1FvEmeaStatus455 struct {
}

func (o *PricingControlUpdateV1FvEmeaStatus455) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaStatus455 ", 455)
}

func (o *PricingControlUpdateV1FvEmeaStatus455) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPricingControlUpdateV1FvEmeaStatus465 creates a PricingControlUpdateV1FvEmeaStatus465 with default headers values
func NewPricingControlUpdateV1FvEmeaStatus465() *PricingControlUpdateV1FvEmeaStatus465 {
	return &PricingControlUpdateV1FvEmeaStatus465{}
}

/*PricingControlUpdateV1FvEmeaStatus465 handles this case with default header values.

Backend Response Code and message in odsMessages field: <BR/><BR/>VPL5SPCZ1S : SERVICE COULD NOT OBTAIN STORAGE AREA<BR/>VPL5SPCZ2S : SERVICE INPUT TO PCT CTRL SERVICE IS AN INCORRECT LENGTH<BR/>VPL5SPCZ3S : FILE-TABLE USED BY THIS SERVICE IS NOT FOUND<BR/>VPL5SPCZ4S : REQUESTED ORGANIZATION COULD NOT BE DETERMINED<BR/>VPL5SPCZ5S : REQUESTED ORGANIZATION NOT FOUND<BR/>VPL5SPCZ6S : FILE-TABLE USED BY THIS SERVICE IS NOT FOUND<BR/>VPL5SPC02S : APPLICATION IN NO-PROCESSING STATUS RE-TRY IN A FEW MINUTES<BR/>VPL5SPC03E : ORGANIZATION IS NOT NUMERIC OR MUST BE VALUE BETWEEN 000 AND 998<BR/>VPL5SPC04E : REQUESTED CARDorACCT NUMBER IS NOT NUMERIC OR EQUAL SPACES<BR/>VPL5SPC05E : INVALID FOREIGN USE INDICATOR - VALID VALUES ARE SPACE 0 OR 1   INVALID FOREIGN USE INDICATOR SPECIFIED - VALID VALUES ARE       SPACE 0 OR 1<BR/>VPL5SPC06E : STATE OF RESIDENCE CONTAINS INVALID CHARACTERS<BR/>VPL5SPC07E : STATE OF ISSUANCE CONTAINS INVALID CHARACTERS<BR/>VPL5SPC08E : PRICING CONTROL ID CONTAINS INVALID CHARACTERS<BR/>VPL5SPC09E : PRICING CONTROL START DATE IS NOT NUMERIC<BR/>VPL5SPC10E : PRICING CONTROL EXPIRES DATE MUST BE A VALID DATE<BR/>VPL5SPC11E : PRICING CONTROL EXPIRE DATE IS NOT NUMERIC<BR/>VPL5SPC12E : PRICING LEVEL OVERRIDE MUST EQUAL SPACE L O OR S<BR/>VPL5SPC13E : PRICING LEVEL START DATE MUST BE A VALID DATE<BR/>VPL5SPC14E : PRICING LEVEL START DATE IS NOT NUMERIC<BR/>VPL5SPC15E : PRICING LEVEL EXPIRES DATE MUST BE A VALID DATE<BR/>VPL5SPC16E : PRICING LEVEL EXPIRES DATE IS NOT NUMERIC<BR/>VPL5SPC17S : APPLICATION IN NO-PROCESSING STATUS RE-TRY IN A FEW MINUTES<BR/>VPL5SPC18S : ORGANIZATION NOT FOUND ON FILE<BR/>VPL5SPC19S : FOREIGN ORGANIZATION NOT FOUND ON FILE<BR/>VPL5SPC20S : ACCOUNT NOT FOUND ON FILE<BR/>VPL5SPC21S : LOGO NOT FOUND ON FILE<BR/>VPL5SPC22E : STATE OF RESIDENCE IS NOT FOUND ON USURY TABLE<BR/>VPL5SPC23E : STATE OF RESIDENCE IS INVALID ON USURY TABLE<BR/>VPL5SPC24E : STATE OF RESIDENCE IS NOT FOUND<BR/>VPL5SPC25E : STATE OF RESIDENCE DOES NOT EXIST<BR/>VPL5SPC26E : STATE OF RESIDENCE DOES NOT MATCH LOGO STATE OF RESIDENCE<BR/>VPL5SPC27E : STATE OF RESIDENCE IS REQUIRED<BR/>VPL5SPC28E : PRICING CONTROL ID IS NOT FOUND<BR/>VPL5SPC29E : PRICING CONTROL ID DOES NOT EXIST<BR/>VPL5SPC30E : ISSUANCE ID REQUIRED FOR BANKCARD ACCOUNT<BR/>VPL5SPC31E : ISSUANCE ID IS NOT FOUND ON USURY TABLE<BR/>VPL5SPC32E : ISSUANCE ID IS INVALID ON USURY TABLE<BR/>VPL5SPC33E : ISSUANCE ID IS NOT FOUND<BR/>VPL5SPC34E : ISSUANCE ID DOES NOT EXIST<BR/>VPL5SPC35E : START DATE INVALID WHEN PCT CNTRL ID NOT PROVIDED<BR/>VPL5SPC36E : START DATE FOR THE PRICING CTRL MUST BE = OR > NEXT PROCESSING DT<BR/>VPL5SPC37E : EXPIRE DATE NOT VALID WHEN START DATE EQUAL ZEROS<BR/>VPL5SPC38E : EXPIRE DATE FOR THE PRICING CTRL MUST BE = OR > PCT START DATE<BR/>VPL5SPC39E : PCT LEVEL START DATE NOT VALID WHEN PRICING CTRL NOT PROVIDED<BR/>VPL5SPC40E : PCT LEVEL START DATE FOR PCT LEVEL MUST BE = OR > NEXT PROCESS DT<BR/>VPL5SPC41E : PCT LEVEL EXPIRE DATE FOR PCT LEVEL MUST BE > START DATE<BR/>VPL5SPC42E : PRICING START DATE CAN NOT BE GREATER THAN PCT EXPIRE DATE<BR/>VPL5SPC43E : PRICING STARTorEXPIRE DATE INVALID WHEN PCT ID EQUAL SPACES<BR/>VPL5SPC44E : PRICING LEVEL EXPIRE DATE LESS THAN PRICING LEVEL START DATE<BR/>VPL5SPC45E : PCT LEVEL STARTorEXPIRE DATES INVALID WHEN PCT LEVEL NOT PROVIDED<BR/>VPL5SPC46S : PCT ENTRY DOES NOT EXIST<BR/>VPL5SPC47S : ACCT CTL TABLE ID INVALID-CSHorRTL PLANSorCHGF ACRINT NOT OBTAINED<BR/>VPL5SPC48S : ACCT CTL TABLE ID INVALID-CSHorRTL PLANSorCHGF ACRINT NOT OBTAINED<BR/>VPL5SPC49I : PRICING CONTROL DATA HAS NOT CHANGED UPDATE BYPASSED<BR/>VPL5SPC50I : FOREIGN USE ORG UNAVAILABLE PROCESSED LOCAL ORG ACCOUNT DATA<BR/>VPL5SPC51E : CONTROLLING PLAN OVERRIDE MUST = F P X OR SPACE<BR/>VPL5SPC52E : PLAN PMT OVERRIDE MUST EQUAL SPACES FOR PREPAID ACCOUNT TYPE<BR/>VPL5SPC53E : FIXED PAYMENTorAMOUNT PERCENT FIELD INVALID<BR/>VPL5SPC54E : FIXED PAYMENTorAMOUNT PERCENT FIELD INVALID WHEN OVERRIDE IS SPACE<BR/>VPL5SPC55E : PAYMENT OVERRIDE MUST EQUAL SPACE<BR/>VPL5SPC56E : FIXED PAYMENTorAMOUNT PERCENT FIELD NOT NUMERI
*/
type PricingControlUpdateV1FvEmeaStatus465 struct {
	Payload *models.FsErrorDetails
}

func (o *PricingControlUpdateV1FvEmeaStatus465) Error() string {
	return fmt.Sprintf("[POST /fv_emea/v1/pricingControlUpdate][%d] pricingControlUpdateV1FvEmeaStatus465  %+v", 465, o.Payload)
}

func (o *PricingControlUpdateV1FvEmeaStatus465) GetPayload() *models.FsErrorDetails {
	return o.Payload
}

func (o *PricingControlUpdateV1FvEmeaStatus465) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.FsErrorDetails)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}
