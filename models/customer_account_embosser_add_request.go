// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CustomerAccountEmbosserAddRequest customer account embosser add request
//
// swagger:model CustomerAccountEmbosserAddRequest
type CustomerAccountEmbosserAddRequest struct {

	//  Max length = 3, New Account Logo: Logo Number of new account. 1 Must be numeric and greater than zeroes2.  Must exist as a valid Logo
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AccountLogo *string `json:"accountLogo,omitempty"`

	//  Max length = 19, Account Number: Number of Customer's account. Must be numeric and greater than zero. This can be either Account number or Card number.
	// Max Length: 19
	// Min Length: 0
	AccountNumber *string `json:"accountNumber,omitempty"`

	//  Max length = 3, Account Organisation: Three digit Identification number of the Organisation.
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AccountOrganization *string `json:"accountOrganization,omitempty"`

	//  Max length = 1, Valid values are  A = Add Account, Blank/Space = No action NOTE: Insurance products may only be added by this service as part of the Add Account process
	// Max Length: 1
	// Min Length: 0
	AccountRecordAction *string `json:"accountRecordAction,omitempty"`

	//  Max length = 1, Code that indicates whether the account being added is a transaction (cardholder), billing, control, or diversion account. The values are: 0 = Account is a transaction account (Default), 1 = Account is a billing account, 2 = Account is a control account, 3 = Account is a diversion account.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AccountType *string `json:"accountType,omitempty"`

	//  Max length = 3, Identification number of the Account Control table used for the account. This table overrides the Account Control table defined by the Processing Control table that is assigned to each account. The table number entered must identify an existing Account Control table established at the Organisation level
	// Max Length: 3
	// Min Length: 0
	AcctCtlOvrrd *string `json:"acctCtlOvrrd,omitempty"`

	//  Max length = 1, VALID VALUES: 0 = No, 1 = Yes
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AcctCustNbrSameInd *string `json:"acctCustNbrSameInd,omitempty"`

	//  Max length = 8, Account generation id: SSC number generation table ID that is applicable for generating the accounts. Default value is spaces.
	// Max Length: 8
	// Min Length: 0
	AcctGenID *string `json:"acctGenId,omitempty"`

	//  Max length = 1, Code that indicates whether the account-level threshold limit check is performed during authorizations. The values are: 0 = Do not perform checks at the account level (Default), 1 = Perform checks at the account level.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AcctLimitCheck *string `json:"acctLimitCheck,omitempty"`

	//  Max length = 1, Card Action Code: Indicates the card issue action code.  Values are:  0 - No action Required,  1 - New Cards,  2 - Additional Cards,  3 - Replacement Cards, 4 - Cancel Cards,  5 - PIN Request , 6 - Emergency Replacement,  7 - Reissue,  8 - Card number scheme reissue,  9 - Card transfer reissue,  A - Additional Card to Account,  B - Replacement Card and Pin Mailer,  R - Random PIN,  L - Lost Card Replacement.
	// Max Length: 1
	// Min Length: 0
	Action *string `json:"action,omitempty"`

	//  Max length = 40, Address Line 1: First line of the address to which the card and PIN mailer is sent.
	// Max Length: 40
	// Min Length: 0
	AddressLine1 *string `json:"addressLine1,omitempty"`

	//  Max length = 40, Address Line 2: Second line of the address to which the card and PIN mailer is sent.
	// Max Length: 40
	// Min Length: 0
	AddressLine2 *string `json:"addressLine2,omitempty"`

	//  Max length = 19, Number that identifies the alternate Customer Name/Address record containing an alternate address for statements.
	// Max Length: 19
	// Min Length: 0
	AltCustNbr *string `json:"altCustNbr,omitempty"`

	// Format: YYYYMMDD. Date on which the alternate customer address expires for statements. If this date is earlier than today's processing date, statements use the address of the primary Customer Name/ Address record, not the alternate Customer Name/Address record.
	AltCustNbrExpireDate string `json:"altCustNbrExpireDate,omitempty"`

	//  Max length = 1, Code that indicates how CMS generates statements when an alternate Customer Name/Address record exists for the account. The values are: A = Alternate customer active; send statement to alternate address until expiration date, B = Alternate customer active; send statement to both addresses until expiration date, C = Relationship customer active; send statement to alternate address, Blank = No action; disregard alternate customer. (Default)
	// Max Length: 1
	// Min Length: 0
	AltCustNbrFlag *string `json:"altCustNbrFlag,omitempty"`

	//  Max length = 1, Annual BIS stament flag: Flag that indicates whether annual statements should be produced and/or the BIS annual credit card statement (ACCS) statistics should be accumulated. Values are: 0 = Do not produce annual statements, 1 = Produce regular annual statements, 2 = Produce ACCS only, 3 = Produce both regular annual statement and ACCS, 4 = Accumulate stats for ACCS without statement generation, 5 = Accumulate stats for ACCS without ACCS generation, and generate the regular annual statement.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AnnStmtFlg *string `json:"annStmtFlg,omitempty"`

	// Format: YYYYMMDD. Date of Application
	ApplicationDate string `json:"applicationDate,omitempty"`

	//  Max length = 17, Maximum amount in monetary units and subunits of ATM cash authorizations allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,17}$
	AtmCashAmount string `json:"atmCashAmount,omitempty"`

	//  Max length = 9, Maximum number of ATM cash authorizations allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,9}$
	AtmCashNumber string `json:"atmCashNumber,omitempty"`

	//  Max length = 17, Maximum authorization amount in monetary units and subunits for ATM transactions allowed daily.
	// Pattern: ^(-)?[0-9]{1,17}$
	AtmDailyAmount string `json:"atmDailyAmount,omitempty"`

	//  Max length = 1, ATM PCKG REQ
	// Max Length: 1
	// Min Length: 0
	AtmPckgReq *string `json:"atmPckgReq,omitempty"`

	//  Max length = 1, Authorization Limit Override Flag: Flag that indicates whether the parameters on the Embosser record for maximum daily authorisations may be overridden. Values are:  0 - Override not allowed (Default), 1 - Override allowed
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AuthLimitOvrrdFlag *string `json:"authLimitOvrrdFlag,omitempty"`

	//  Max length = 1, Authorization message The values are: 0 = Authorization message is not active, 1 = Authorization message is active, 2 = Authorization message is active on fee.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AuthMsg *string `json:"authMsg,omitempty"`

	//  Max length = 9, Authorization Threshold: An authorization amount equal to or greater than this amount initiates a text message to the cardholder.
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AuthThres *string `json:"authThres,omitempty"`

	//  Max length = 4, Direct Debit Bank ID code.  Default value would be spaces.
	// Max Length: 4
	// Min Length: 0
	BankCode *string `json:"bankCode,omitempty"`

	//  Max length = 1, Code that indicates whether billing occurs for the account at the relationship level or subordinate account level. The values are: 0 = Relationship level, 1 = Subordinate account level. (Default)
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	BillingLevel *string `json:"billingLevel,omitempty"`

	//  Max length = 1, Block code assigned to this card.
	// Max Length: 1
	// Min Length: 0
	BlockCode *string `json:"blockCode,omitempty"`

	//  Max length = 1, This identifies the block code 1 assigned to this account. Block codes control specific processing options at the account level. Valid block codes are the letters A to Z and blank (or space).
	// Max Length: 1
	// Min Length: 0
	BlockCode1 *string `json:"blockCode1,omitempty"`

	//  Max length = 1, This identifies the block code 2 assigned to this account. Block codes control specific processing options at the account level. Valid block codes are the letters A to Z and blank (or space).
	// Max Length: 1
	// Min Length: 0
	BlockCode2 *string `json:"blockCode2,omitempty"`

	//  Max length = 9, Branch number that identifies the card mailing location for the issue of all new cards when the branch delivery option is used.
	// Max Length: 9
	// Min Length: 0
	BranchNumber *string `json:"branchNumber,omitempty"`

	//  Max length = 5, Last Credit Score received from a Credit Bureau. The value must be numeric. If the score is negative then the last position must have  a minus sign (-)
	// Pattern: ^(-)?[0-9]{1,5}$
	BureauScr string `json:"bureauScr,omitempty"`

	//  Max length = 1, Card Action Reason: User-defined reason code associated with the current card issue action code. This field can identify specific notations to print in card and PIN mailers.
	// Max Length: 1
	// Min Length: 0
	CardActionReason *string `json:"cardActionReason,omitempty"`

	//  Max length = 8, Card generation id: Identification number of the SSC number generation table ID that is applicable for generating physical cards under this account. Default value is spaces.
	// Max Length: 8
	// Min Length: 0
	CardGenID *string `json:"cardGenId,omitempty"`

	//  Max length = 1, Card Statement. Valid values are:  0 - Default value. No card transaction summary statement. Card transaction summary statement to be generated even if cards spend is zero in the cycle. 2- Card transaction summary statement should be generated only for cards that have a spend in the cycle. For cards that do not have any spend the card transaction summary statement should not be generated.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CardStatement *string `json:"cardStatement,omitempty"`

	//  Max length = 1, Flag that identifies the current card technology used for this account. The values are: 0 = Magnetic-stripe card(s) are on issue, 1 = Smart card(s) are on issue. When adding an account, system uses the card technology from the account's logo as the default value. You can override this default if necessary.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CardTech *string `json:"cardTech,omitempty"`

	//  Max length = 1, Cardholder Type: Code that indicates whether the card is issued as a primary or secondary card. The values are: 0 = Additional Cardholder, 1 = Primary Cardholder
	// Max Length: 1
	// Min Length: 0
	CardholderType *string `json:"cardholderType,omitempty"`

	//  Max length = 1, Credit Bureau Indicator: Code that determines the credit bureau reporting of the account.  Values are: 0 - Logo level parameters control the selection of the account (default value), 1 - Do not report the account to the Credit Bureau, 2 - Always report the account to the Credit Bureau
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CbIndicator *string `json:"cbIndicator,omitempty"`

	//  Max length = 3, Intermediary Code 1.  The input code should exist in the new intermediary code table.  If the input code is not found, '000' will be populated in base segment field, and a warning message will be returned in the response message. 2. When an intermediary code value is not supplied on the input message, spaces will be populated in the account base segment field.
	// Max Length: 3
	// Min Length: 0
	CcdIntCode *string `json:"ccdIntCode,omitempty"`

	//  Max length = 1, Channel Indicator: Code indicating the preferred electronic correspondence channel. Values are: 0 = Off, 1 = Email, 2 = SMS, 3 = Email and SMS
	// Max Length: 1
	// Min Length: 0
	ChanInd *string `json:"chanInd,omitempty"`

	//  Max length = 40, Client Refenence Indicator for this account
	// Max Length: 40
	// Min Length: 0
	ClientRefInd *string `json:"clientRefInd,omitempty"`

	//  Max length = 2, Collateral code
	// Max Length: 2
	// Min Length: 0
	ColatCode *string `json:"colatCode,omitempty"`

	// common
	Common *Header `json:"common,omitempty"`

	//  Max length = 1, Code that indicates whether to allow ordering of convenience chequebooks. The values are: A = Chequebook issued when account added, N = No chequebook issued and supported, C = Chequebooks supported and issued, S = Chequebooks issued in the past and no cheque book issued in future, E = Manual order of chequebooks, F = Chequebook issue failed, G = Chequebook issue failed (Manually ordered), H = Chequebook issue failed (Automatic reissue), R = Automatic reissue of chequebooks.
	// Max Length: 1
	// Min Length: 0
	ConvChequeOrdering *string `json:"convChequeOrdering,omitempty"`

	//  Max length = 1, This user-defined field would give the dispatch method for convenience chequebooks to be issued. This field is used by the operator along with the CONV CHEQUE ORDERING flag whenever new chequebooks are to be issued. Values are:  'C' - Return to Card Centre, 'D' - Direct to Cardholder, 'F' - First Class Mail, 'R' - Recorded Delivery
	// Max Length: 1
	// Min Length: 0
	ConvChqbookDispatchMethod *string `json:"convChqbookDispatchMethod,omitempty"`

	//  Max length = 19, Identify the correspondence customer number of an account.  This field indicates a permanent address that is to be used in lieu of the primary residential address attached to the customer
	// Max Length: 19
	// Min Length: 0
	CorresCustNbr *string `json:"corresCustNbr,omitempty"`

	//  Max length = 1, Credit Limit Alert Opt-in/out Flag: Flag that will indicate account is opted for credit limit proximity alert.  Values are:  0 - Alert Option is not opted,  1 - Alert will be sent via SMS,  2 - Alert will be sent via cardholder EMAIL,  3 - Both Email and SMS alert will be sent ,  9 - Prefer Product Level/Logo Alert Option
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CrdtLmtAlert *string `json:"crdtLmtAlert,omitempty"`

	//  Max length = 9, Credit Limit Proximity Amount: Amount after which Credit Limit alert is initiated
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CrdtLmtAmt *string `json:"crdtLmtAmt,omitempty"`

	//  Max length = 17, Credit limit of the account. For relationship accounts, usually you will add the Relationship record and enter the relationship credit limit  before adding subordinate accounts. In this case, the available credit limit is reduced as subordinate accounts are added to the relationship. if existing accounts with previously assigned credit limits are assigned to a relationship, the  relationship credit limit must be greater than or equal to the sum of the credit limits of the subordinate accounts.
	// Pattern: ^(-)?[0-9]{1,17}$
	CreditLmt string `json:"creditLmt,omitempty"`

	//  Max length = 1, Credit Limit Bypass Indicator: indicator that determines whether an account is excluded for credit limit review by TRIAD.  Values are:  0 - Include (Default),  1 - Exclude from credit limit increase,  2 - Exclude from credit limit decrease,  3 - Exclude from credit limit decision area.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CrlimBypsInd *string `json:"crlimBypsInd,omitempty"`

	//  Max length = 17, Customer Credit limit.
	// Max Length: 17
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CustCrlim *string `json:"custCrlim,omitempty"`

	//  Max length = 19, Identification number of the Customer Name/Address record
	// Max Length: 19
	// Min Length: 0
	CustNbr *string `json:"custNbr,omitempty"`

	//  Max length = 3, Organisation Number: Three digit Identification number of the Organisation.  Valid values are 001 - 998. Organisation number must be on file.
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CustOrg *string `json:"custOrg,omitempty"`

	//  Max length = 1, Customer Unsolicited Credit Limit Increase preference Valid Values are 0, 1, 4.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CustUcliPref *string `json:"custUcliPref,omitempty"`

	//  Max length = 19, Customer number: Customer number that identifies the Customer Name/Address record to which this account is assigned.
	// Max Length: 19
	// Min Length: 0
	CustomerNumber *string `json:"customerNumber,omitempty"`

	//  Max length = 1, Valid values are  A = Add Customer, U = Update Customer, Blank/Space = No action NOTE: Marketing Preference data is only added or updated by this service as part of Add or Update to Customer
	// Max Length: 1
	// Min Length: 0
	CustomerRecordAction *string `json:"customerRecordAction,omitempty"`

	//  Max length = 2, Cycle code that indicates the day of the month that CMS performs cycle processing for the account. The values are 01-31. Required unless cycle smoothing parameters are active. If the cycle code falls on a non processing day, billing occurs on the day that precedes the non-processing day, but the account accrues through the last non processing day. Example: If the cycle code falls on a Saturday and the processing center has designated Saturday and Sunday as Non processing days, billing occurs on
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	Cycle *string `json:"cycle,omitempty"`

	// Format: MMYY. Card Expiration date
	// Max Length: 4
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DateCardExpr *string `json:"dateCardExpr,omitempty"`

	// Format: YYYYMMDD. Indicates the date on which the most recently issued card expires.
	DateExpire string `json:"dateExpire,omitempty"`

	// Format: YYYYMMDD. Date Opened: Date on which the account was opened. NOTE:  if the service Input field equals low values, the OPENED field will contain the current processing date.  Field must be numeric. Field must be a valid Julian date. Date cannot be greater than current processing date. Date cannot be a zero value.
	DateOpened string `json:"dateOpened,omitempty"`

	//  Max length = 11, Bank identifier code (BIC) associated with the Direct Credit account. A SWIFT code is an international bank code that identifies particular banks worldwide. Required if the IBAN flag on the Logo is equal to 1.
	// Max Length: 11
	// Min Length: 0
	DcBic *string `json:"dcBic,omitempty"`

	//  Max length = 8, Digital Card generation id: Identification number of the SSC number generation table ID that is applicable for generating digital cards under this account. Default value is spaces.
	// Max Length: 8
	// Min Length: 0
	DcGenID *string `json:"dcGenId,omitempty"`

	//  Max length = 34, International Banking Account Number (IBAN) associated with the Direct Credit account. This field is required when the IBAN field on the Logo is 1 and the DD ACCOUNT field is greater than zeros
	// Max Length: 34
	// Min Length: 0
	DcIban *string `json:"dcIban,omitempty"`

	//  Max length = 17, Bank Account number associated with direct debit processing for the account
	// Max Length: 17
	// Min Length: 0
	DdAchAccountNumber *string `json:"ddAchAccountNumber,omitempty"`

	//  Max length = 2, Direct Credit request days. Number of days prior to the payment due date or the day of the month to request direct credit payments for the account.
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DdAchReqDay *string `json:"ddAchReqDay,omitempty"`

	//  Max length = 1, Account Type. The values are: D = Demand deposit account (checking), S = Savings account. For non-prepaid accounts, valid values are D or S. For prepaid accounts, this field be initialised to a value of D.
	// Max Length: 1
	// Min Length: 0
	DdAchType *string `json:"ddAchType,omitempty"`

	//  Max length = 11, Bank Identifier Code (BIC) associated with the Direct Debit account. A SWIFT code is an international bank code that identifies particular banks worldwide. Required if the IBAN flag on the Logo is equal to 1.
	// Max Length: 11
	// Min Length: 0
	DdBic *string `json:"ddBic,omitempty"`

	//  Max length = 34, International Banking Account Number (IBAN) associated with the Direct Debit account. This field is required when the IBAN field on Logo is 1 and the DD ACCOUNT field is greater than zeros
	// Max Length: 34
	// Min Length: 0
	DdIban *string `json:"ddIban,omitempty"`

	//  Max length = 17, Direct Debit amount or precentage. For non-prepaid accounts this field must be numeric. If the DdNomAmtPctFlag flag is equal to 0 or 3, the amount field must equal zeros. If the DdNomAmtPctFlag is equal to 1 or 2, the amount field must be greater than zeros. If the DdNomAmtPctFlag equals 2, the amount must be greater than zero and less than 100%. NOTE: For prepaid accounts, this field will be initialised to zeros.
	// Pattern: ^(-)?[0-9]{1,17}$
	DdNomAchAmt string `json:"ddNomAchAmt,omitempty"`

	//  Max length = 1, This field indicates what field DdNomAchAmt field will contain. Two part field 0 = Not used. Second part must be blank. 1 = Fixed payment amount. Second part must be an amount, 2 = Percentage of account (cycle-ending) balance. Second must be a percentage (max 99%), 3 = Full account (cycle-ending) balance. Second part must be zeros, 9 = Percentage of account (cycle-ending minus overlimit amount) balance. Second part must be a percantage (max 99%)
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DdNomAmtPctFlag *string `json:"ddNomAmtPctFlag,omitempty"`

	//  Max length = 1, Direct debit processing(DD) code for account 0 = no DD(Default), 1 = DD active. Min. payment. Includes past due amounts for projected DD, 2 = DD active. Nominated payment. Includes past due amounts for proj. DD, 3 = DD expired (system-generated), 4 = DD cancelled. Delinquency (system gen.), 5 = DD cancelled.Reached DD PAYMENT REVERSAL LIMIT(system gen.), 6 = DD active for debit card transactions only(system gen.), 7 = DD active. A customer nominated pay. is in effect. Not including past dues for proj.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DdPayment *string `json:"ddPayment,omitempty"`

	//  Max length = 10, Dual-use field accepting a nine-digit routing/transit number (ACH format) or a ten-digit bank ID (non-ACH format) to identify the financial institution to receive direct debit transactions for account payments: ACH format = 0 + nine-digit routing/transit number Non-ACH format = ten-digit bank ID When you enter a nine-digit routing/transit number (ACH format), the leading digit must be zero. The ORG record indicates if this field accepts a nine-digit routing/transit number or a ten-digit bank ID
	// Max Length: 10
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DdRtBankid *string `json:"ddRtBankid,omitempty"`

	//  Max length = 19, DD account number  Default value is 'Spaces'
	// Max Length: 19
	// Min Length: 0
	DdaAcctNbr *string `json:"ddaAcctNbr,omitempty"`

	//  Max length = 9, DD Routing number  Default value is 'Zeroes'
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DdaRtngNbr *string `json:"ddaRtngNbr,omitempty"`

	//  Max length = 5, Default Cash Plan for the account. If no value received then it will default from the Account Control Table associated with the PCT ID of the new account. If an Account Control Override Table is specified, then default from that.
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DefaultCashPlan *string `json:"defaultCashPlan,omitempty"`

	//  Max length = 5, Identification number of a promotional Credit Plan Master record. Also called 'phantom' plans. The system  uses 'phantom' plans to provide disclosure information when an account does not have any active cash, retail , or promotional credit plans.  The plan numbers entered must identify existing Credit Plan Master records previously added into system
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DefaultPromoPlan *string `json:"defaultPromoPlan,omitempty"`

	//  Max length = 5, Default Retail Plan for the account. If no value received then default from the Account Control Table associated with the PCT ID of the new account. If Account Control Override Table is specified, then default from that.
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DefaultRetailPlan *string `json:"defaultRetailPlan,omitempty"`

	//  Max length = 3, Delivery Point Suffix Address.
	// Max Length: 3
	// Min Length: 0
	DeliveryPointSuffix *string `json:"deliveryPointSuffix,omitempty"`

	//  Max length = 1, Digital Card Indicator: Code that indicates if the account has a digital card or not. Valid values are:  0 - No digital card, Account has only physical plastic (default), 1 - Digital card only, account has no physical plastic,  2 - Account has both digital card and physical plastic
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DigitalCardInd *string `json:"digitalCardInd,omitempty"`

	//  Max length = 1, Disability Indicator: used to identify customers (at account level) that have a requirement for correspondence to be sent in a particular format.  Values are: Space = Not used (Default), A = Audio, B = Braille, C = CD-ROM, H = Hard of hearing/Minicom, L = Large print, P = Plain text, E = Elderly (old age), M = Mental difficulties, O = Other.
	// Max Length: 1
	// Min Length: 0
	DisabilityInd *string `json:"disabilityInd,omitempty"`

	//  Max length = 2, Valid values are zeros through 31. If the Logo default Due Date equals zeros, the DUE field must equal zeros. If the CYCLE field equals zeros, the DUE field must be greater than zeros
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	Due *string `json:"due,omitempty"`

	//  Max length = 1, Gender code. Values are: 0 - Gender not specified, 1 - Male 2 - Female
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EdGenderCode *string `json:"edGenderCode,omitempty"`

	//  Max length = 10, Postal code or zip code of the mailing address for card and PIN mailer.
	// Max Length: 10
	// Min Length: 0
	EdPostalCode *string `json:"edPostalCode,omitempty"`

	//  Max length = 20, User-defined 1. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 20
	// Min Length: 0
	EdUser1 *string `json:"edUser1,omitempty"`

	//  Max length = 20, User-defined 2. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 20
	// Min Length: 0
	EdUser2 *string `json:"edUser2,omitempty"`

	//  Max length = 19, User-defined 3. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 19
	// Min Length: 0
	EdUser3 *string `json:"edUser3,omitempty"`

	//  Max length = 4, User-defined 4. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 4
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EdUser4 *string `json:"edUser4,omitempty"`

	//  Max length = 1, User-defined 5. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 1
	// Min Length: 0
	EdUser5 *string `json:"edUser5,omitempty"`

	//  Max length = 1, User-defined 6. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 1
	// Min Length: 0
	EdUser6 *string `json:"edUser6,omitempty"`

	//  Max length = 1, User-defined 7. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 1
	// Min Length: 0
	EdUser7 *string `json:"edUser7,omitempty"`

	//  Max length = 1, User-defined 8. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 1
	// Min Length: 0
	EdUser8 *string `json:"edUser8,omitempty"`

	//  Max length = 30, City for the mailing address to be used for card and PIN mailer.
	// Max Length: 30
	// Min Length: 0
	EmbCity *string `json:"embCity,omitempty"`

	//  Max length = 1, Cardholder's preferred method of PIN delivery. Values are: 0 - PIN is delivered by paper PIN mailer 1 - PIN is delivered by SMS 2 - Deliver PIN by PIN Now Web
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EmbPinCommPref *string `json:"embPinCommPref,omitempty"`

	//  Max length = 20, Memorable word: Memorable word used for SMS PIN Data.   Values are: - A to Z - 0-9 - Space - Underscore - Full stop Mandatory if customer chooses PIN by SMS mode or logo level preference is SMS.
	// Max Length: 20
	// Min Length: 0
	EmbPinMemWord *string `json:"embPinMemWord,omitempty"`

	//  Max length = 20, Mobile number to which the SMS containing the PIN information is sent. The mobile number is in the international number format, without '+' char. The field should be left justified and space filled and should contain only numeric data. There should not be any space in between the digits. There should not be any leading zeroes. This field is mandatory if customer chooses to receive the PIN by SMS mode or if the LOGO level PIN communication preference is SMS.
	// Max Length: 20
	// Min Length: 0
	EmbPinMobileNbr *string `json:"embPinMobileNbr,omitempty"`

	//  Max length = 5, Affiliate Emblem. Code that defines the cardholder's affiliation or affinity group. The values are user-defined. If this field is left blank during account setup, system populates this field with the value from the Logo record
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	Emblm *string `json:"emblm,omitempty"`

	//  Max length = 26, Embossed Name 1: Name embossed on the first embossing line of the card.
	// Required: true
	// Max Length: 26
	// Min Length: 0
	EmbossedName1 *string `json:"embossedName1"`

	//  Max length = 26, Embossed Name 2: Additional Name to be embossed on the second embossing line of the card.
	// Max Length: 26
	// Min Length: 0
	EmbossedName2 *string `json:"embossedName2,omitempty"`

	//  Max length = 1, Embossed Name Type 1: Type of name for EmbossedName1. This field is only used for prepaid cards.  Values are: 0 = Personal name (Default), 3 = Generic name. If you enter 3 for the type and leave the EmbossedName1 field blank, the embossed name defaults from the Logo default card Name Line 2.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EmbossedNameType1 *string `json:"embossedNameType1,omitempty"`

	//  Max length = 1, Embossed Name Type 2: Type of name for EmbossedName2. This field is only used for prepaid cards.  Values are: 0 = Personal name (Default) 3 = Generic name. If you enter 3 for the type and leave the EmbossedName2 field blank, the embossed name defaults from the Logo default card Name Line 2.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EmbossedNameType2 *string `json:"embossedNameType2,omitempty"`

	//  Max length = 1, Valid values are  A = Add Embosser, Blank/Space = No action NOTE: for Add Embosser at least one Card Logo must be provided in MsCardLogoTable of this driver service
	// Max Length: 1
	// Min Length: 0
	EmbosserRecordAction *string `json:"embosserRecordAction,omitempty"`

	//  Max length = 2, Type of Card: Indicates the type of plastic stock.
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EmbossingCard *string `json:"embossingCard,omitempty"`

	//  Max length = 2, Type Card Mailer: Identifies the type of card mailer to use to post the card.
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EmbossingMail *string `json:"embossingMail,omitempty"`

	//  Max length = 2, Identifies the type of card requested
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EmbossingReq *string `json:"embossingReq,omitempty"`

	//  Max length = 40, Card Name 1 of the Cardholder, used for mailing card and PIN mailers.
	// Max Length: 40
	// Min Length: 0
	EmbrName1 *string `json:"embrName1,omitempty"`

	//  Max length = 40, Card Name 2 of the cardholder, used for mailing card and PIN mailers.
	// Max Length: 40
	// Min Length: 0
	EmbrName2 *string `json:"embrName2,omitempty"`

	//  Max length = 15, Employee ID: User-defined employee identification number of an account holder who is eligible for employee and shareholder discounts.
	// Max Length: 15
	// Min Length: 0
	EmpID *string `json:"empId,omitempty"`

	//  Max length = 2, User-defined Employee Code If provided, it should be an Alphanumeric field.
	// Max Length: 2
	// Min Length: 0
	EmployeeCode *string `json:"employeeCode,omitempty"`

	// Format: YYYYMMDD. Date on which the special pricing controls expire for the account. The PricingCtrl field identifies the special pricing controls. The ExpirationDate must be greater than the StartDate.
	ExpirationDate string `json:"expirationDate,omitempty"`

	// Format: YYYYMMDD. Date on which the temporary line of credit expires. This date must be equal to or greater than today's processing date. This field is required if you enter a temporary line of credit. The default is zero. If this is zeroes there is no temporary limit in effect.
	Expires string `json:"expires,omitempty"`

	//  Max length = 2, Month in which the fiscal year ends for the commercial card customer. Valid values  are: 00 - Do not produce report at MCC level (Default) 01 - 12 - Produce reports at MCC level for this account. Numbers 01 - 12 denote the fiscal month for the account when the fiscal yearend report is produced.  Valid values are: 01-January,  02-February, 03-March, 04-April, 05-May, 06-June, 07-July, 08-August, 09-September, 10-October, 11-November, 12-December
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	FiscalYearEnd *string `json:"fiscalYearEnd,omitempty"`

	//  Max length = 1, Code that indicates whether CMS uses the foreign or local currency to request the minimum payment. The values are: 0 = Dual billing is not active. Bill the foreign account in the foreign currency. Two statements are generated, one in the foreign currency and one in the local currency. 1 = Dual billing is active. Bill the foreign account in the local currency. Two statements are generated in the local currency.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	ForeignBilling *string `json:"foreignBilling,omitempty"`

	//  Max length = 1, Foreign use indicator: Value indicates whether the incoming action is applied to the local or foreign account. The values are 0 = Local account (default), 1 = Foreign account, SPACE = defaults to 0
	// Max Length: 1
	// Min Length: 0
	ForeignInd *string `json:"foreignInd,omitempty"`

	//  Max length = 5, Fixed Payment Plan plan number
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	FppPlanNbr *string `json:"fppPlanNbr,omitempty"`

	//  Max length = 1, This field will indicate the frequency for the maximum authorization parameters. The values for this field is:  0= Not used(Default), 1 = Daily, 2 = Cycle-to-date, 3 = year-to-date
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	Frequency *string `json:"frequency,omitempty"`

	//  Max length = 1, Flag that indicates whether this account can qualify for the accumulation and/or redemption of frequent shopper points.   Valid values are:  Y'- Yes, this account can qualify for frequent shopper points (Default), N - No, this account cannot qualify for frequent shopper points.
	// Max Length: 1
	// Min Length: 0
	FsFlag *string `json:"fsFlag,omitempty"`

	//  Max length = 9, Identification number of the store where the employee account application was made
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	HomeStoreNbr *string `json:"homeStoreNbr,omitempty"`

	//  Max length = 3, Merchant Organisation number of the employee's home store. Used in Staff Discount products
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	HomeStoreOrg *string `json:"homeStoreOrg,omitempty"`

	//  Max length = 2, IBS Default account: This field is used to indicate which bank account details are to be used by Base24 as the default account in authorizations.  Values are:  00 - No IBS DDA or Savings bank account details are held (Default value)), 10 -  SAVINGS ACCOUNT and SAV R/T BANK ID to be default account,  20 - DDA ACCOUNT and DDA R/T  / BANK ID to be default account
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	IbsAcctDflt *string `json:"ibsAcctDflt,omitempty"`

	//  Max length = 17, Demand Deposit Account (DDA) number associated with Direct Debit processing.
	// Max Length: 17
	// Min Length: 0
	IbsDdaAcctNbr *string `json:"ibsDdaAcctNbr,omitempty"`

	//  Max length = 10, DDA Routing Number:  Dual-use field that accepts a nine-digit routing/transit number (ACH format) or a ten-digit Bank ID (non-ACH format) to identify the financial institution to receive Direct Debit transactions for account payments. Any entered number must be right aligned with leading zeros.
	// Max Length: 10
	// Min Length: 0
	// Pattern: ^[0-9]*$
	IbsDdaRtngNbr *string `json:"ibsDdaRtngNbr,omitempty"`

	//  Max length = 17, Savings account number associated with Direct Debit processing.
	// Max Length: 17
	// Min Length: 0
	IbsSavAcctNbr *string `json:"ibsSavAcctNbr,omitempty"`

	//  Max length = 10, Saving Rating number. Routing and transit number that identifies the financial institution at which the savings account is held.
	// Max Length: 10
	// Min Length: 0
	// Pattern: ^[0-9]*$
	IbsSavRtngNbr *string `json:"ibsSavRtngNbr,omitempty"`

	//  Max length = 5, Last Credit Score generated by an in-house system. The last position contains a minus sign (-) if the score is negative.
	// Pattern: ^(-)?[0-9]{1,5}$
	InHouseScr string `json:"inHouseScr,omitempty"`

	//  Max length = 17, Income of the account holder in thousands of monetary units. Example: If the currency is U.S. dollars, an income of $100,000 is entered as 100. An income of $28,000 is entered as 28.
	// Pattern: ^(-)?[0-9]{1,17}$
	Income string `json:"income,omitempty"`

	//  Max length = 16, Instant Credit Number: Number that is used to authorise transactions during the instant credit period, which is between account boarding and card activation.
	// Max Length: 16
	// Min Length: 0
	// Pattern: ^[0-9]*$
	InstCrCardNbr *string `json:"instCrCardNbr,omitempty"`

	//  Max length = 3, Temporary card security code to be used instead of CVC2 on instant cards.
	// Max Length: 3
	// Min Length: 0
	InstCrFbsc *string `json:"instCrFbsc,omitempty"`

	//  Max length = 8, Number generation table number for instant credit number
	// Max Length: 8
	// Min Length: 0
	InstCrNbrGenID *string `json:"instCrNbrGenId,omitempty"`

	// insurance product table
	InsuranceProductTable []*InsuranceProductTableForCustomerAccountEmbosserAdd1 `json:"insuranceProductTable"`

	//  Max length = 3, Code that identifies the state, province, or country in which the account was issued. If you leave this field blank, the default is the issuance ID code established on the product.
	// Max Length: 3
	// Min Length: 0
	IssuanceID *string `json:"issuanceId,omitempty"`

	//  Max length = 9, Branch number that identifies the card mailing location for the issue of all new cards when the branch delivery option is used.
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	IssueBranch1st *string `json:"issueBranch1st,omitempty"`

	//  Max length = 3, Issue Delivery Option: Identifies the delivery option for new cards.  Values are: 0 - Regular mail (Default), 1 - First class mail, 2 - Registered mail, 3 - Return to Bank, 004-009 - User defined, 10 - Virtual Card, 11 - Ghost Card
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	IssueDelivOption1st *string `json:"issueDelivOption1st,omitempty"`

	//  Max length = 3, Language Code: User-defined code to indicate the language spoken by the cardholder.
	// Max Length: 3
	// Min Length: 0
	LangCode *string `json:"langCode,omitempty"`

	// MAKER COMAKER TABLE
	MakerComakerTable []*MakerComakerTableForCustomerAccountEmbosserAdd1 `json:"makerComakerTable"`

	// marketing channels data
	MarketingChannelsData []*MarketingChannelsDataForCustomerAccountEmbosserAdd1 `json:"marketingChannelsData"`

	//  Max length = 1, Marketing opt out options: Code that indicates whether the customer has opted out ofmarketing campaigns.  The values are: 0 = Customer has not opted out of marketing campaigns (Default), 1 = Customer has opted out of marketing campaigns at the joint venture level only, 2 = Customer has opted out of marketing campaigns at the group level only, 3 = Customer has opted out of marketing campaigns at both the joint venture and group levels.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	MarketingOptOut *string `json:"marketingOptOut,omitempty"`

	// Marketing Products Data Group. Occurrence 1 is for owner Occurrence 2 is for co-Owner
	MarketingProductsData []*MarketingProductsDataForCustomerAccountEmbosserAdd1 `json:"marketingProductsData"`

	//  Max length = 3, ISO currency code used to generate converted memo-billing info on statements for this account. 000 = Memo billing is not active. system does not generate converted memo billing info. (Default) 001-999 = Memo billing is active. System generates converted memo-billing info in the currency identified by this currency code. If DUAL BILLING is 1 (bill foreign account in local account currency; produce one statement), MemoBillCurrency must be 000 on both the foreign account and the local account.
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	MemoBillCurrency *string `json:"memoBillCurrency,omitempty"`

	//  Max length = 20, Memorable Word entered by the user. Memorable Word of a card-holder can be 'viewed', 'set up' or 'amended' based on the user access security on the customer record. Memorable Word can have numeric/ alpha/ alphanumeric characters only - with a minimum of 8 characters and a maximum of 20 Characters - based on the Org Control Parameters for this field
	// Max Length: 20
	// Min Length: 0
	MemorableWord *string `json:"memorableWord,omitempty"`

	//  Max length = 30, Alphanumeric field used to store the reminder word. Memorable Word Reminder can be 'viewed', 'set up' or 'amended' based on the user access security on the customer record. Memorable Word Reminder allows free form text up to 30 characters. Like the Memorable Word, this field will also be parameterised at the Org level
	// Max Length: 30
	// Min Length: 0
	MemorableWordReminder *string `json:"memorableWordReminder,omitempty"`

	//  Max length = 1, Visa Mini Indicator: Code that indicates the version of Visa Mini card. Values are: 0 = Standard card (Default) 1 = Visa Mini stand-alone card 2 = Visa Mini companion card
	// Max Length: 1
	// Min Length: 0
	Mini *string `json:"mini,omitempty"`

	//  Max length = 5, Miscellaneous Credit Score for the account. The last position contains a minus sign (-) if the score is negative.
	// Pattern: ^(-)?[0-9]{1,5}$
	MiscScr string `json:"miscScr,omitempty"`

	//  Max length = 30, MISC USER 1
	// Max Length: 30
	// Min Length: 0
	MiscUser1 *string `json:"miscUser1,omitempty"`

	//  Max length = 2, MISC USER 10
	// Max Length: 2
	// Min Length: 0
	MiscUser10 *string `json:"miscUser10,omitempty"`

	//  Max length = 2, MISC USER 11
	// Max Length: 2
	// Min Length: 0
	MiscUser11 *string `json:"miscUser11,omitempty"`

	//  Max length = 2, MISC USER 12
	// Max Length: 2
	// Min Length: 0
	MiscUser12 *string `json:"miscUser12,omitempty"`

	//  Max length = 1, MISC USER 2
	// Max Length: 1
	// Min Length: 0
	MiscUser2 *string `json:"miscUser2,omitempty"`

	//  Max length = 11, Miscellaneous User field 3: User-defined miscellaneous information about the account. Default value would be spaces.
	// Max Length: 11
	// Min Length: 0
	MiscUser3 *string `json:"miscUser3,omitempty"`

	//  Max length = 11, Miscellaneous User field 4: User-defined miscellaneous information about the account. Default value would be spaces.
	// Max Length: 11
	// Min Length: 0
	MiscUser4 *string `json:"miscUser4,omitempty"`

	//  Max length = 11, MISC USER 5
	// Max Length: 11
	// Min Length: 0
	MiscUser5 *string `json:"miscUser5,omitempty"`

	//  Max length = 11, MISC USER 6
	// Max Length: 11
	// Min Length: 0
	MiscUser6 *string `json:"miscUser6,omitempty"`

	//  Max length = 11, MISC USER 7
	// Max Length: 11
	// Min Length: 0
	MiscUser7 *string `json:"miscUser7,omitempty"`

	//  Max length = 11, MISC USER 8
	// Max Length: 11
	// Min Length: 0
	MiscUser8 *string `json:"miscUser8,omitempty"`

	//  Max length = 2, MISC USER 9
	// Max Length: 2
	// Min Length: 0
	MiscUser9 *string `json:"miscUser9,omitempty"`

	//  Max length = 20, MOB Device ID: Identification of a mobile device associated with a mobile payment instrument (PI) embosser.
	// Max Length: 20
	// Min Length: 0
	MobDeviceID *string `json:"mobDeviceId,omitempty"`

	//  Max length = 1, Mobile Payment Instrument Allowed: Flag to indicate whether mobile payment instruments can be boarded to an account. Values are: 0 - Do not allow mobile PIs (Default), 1 - Allow mobile PIs
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	MobPiAllowed *string `json:"mobPiAllowed,omitempty"`

	//  Max length = 1, MOB Provision Status: Code that indicates whether the embosser is for a mobile payment instrument (PI) and the current provisioning status for the PI. Values are:  0 - Not applicable; not a mobile PI. (Default), 1 - Mobile PI is ready to be provisioned,  2 - Mobile PI provisioning is complete,  3 - Previous provisioning of the mobile PI was unsuccessful,  4 - Previously provisioned mobile PI is removed and cannot be reprovisioned; the embosser is inactive.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	MobProvStatus *string `json:"mobProvStatus,omitempty"`

	// 5 Occurrences - Indicates which logos the driver should generate cards for (e.g. embosser record)
	MsCardLogoTable []*MsCardLogoTableForCustomerAccountEmbosserAdd1 `json:"msCardLogoTable"`

	//  Max length = 19, Multi Scheme Card Set ID: set to the first card number established for an individual cardholder if it is not provided.
	// Max Length: 19
	// Min Length: 0
	MultiSchemeCardSetID *string `json:"multiSchemeCardSetId,omitempty"`

	//  Max length = 2, Number of Cards Requested. Cannot be greater than 1 if a Smart card. Must be greater than 0 and less than CARDS:OUTSTANDING if ACTION = 3, 6. If ACTION = 5, this field must be 0.
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	NbrCardsRequested *string `json:"nbrCardsRequested,omitempty"`

	//  Max length = 8, New Account Campaign code to drive the retail offer message on the card carrier for new logo. If no value is received, then default the field as spaces.
	// Max Length: 8
	// Min Length: 0
	NewAcctCampaign *string `json:"newAcctCampaign,omitempty"`

	//  Max length = 10, Offer Code Override: Used to override the logo level OFFER CODE parameter.
	// Max Length: 10
	// Min Length: 0
	OfferCodeOvrd *string `json:"offerCodeOvrd,omitempty"`

	//  Max length = 3, Officer code
	// Max Length: 3
	// Min Length: 0
	OfficerCode *string `json:"officerCode,omitempty"`

	//  Max length = 1, Offline Pin: Flag that indicates whether the card supports offline PIN processing. Corresponding field is determined by Card Type (MC, Visa, AMEX, etc.) Values are: 0 = No, offline PIN is not supported (Default) - Chip and Signature Card, 1 = Yes, offline PIN is supported.- Chip and PIN Card
	// Max Length: 1
	// Min Length: 0
	OfflinePin *string `json:"offlinePin,omitempty"`

	//  Max length = 11, On Demand Direct Credit BIC: Bank identifier code associated with the on-demand direct credit account.
	// Max Length: 11
	// Min Length: 0
	OndemDcBic *string `json:"ondemDcBic,omitempty"`

	//  Max length = 34, On Demand Direct Credit IBAN: International Banking Account Number (IBAN) associated with the on-demand direct credit account.
	// Max Length: 34
	// Min Length: 0
	OndemDcIban *string `json:"ondemDcIban,omitempty"`

	//  Max length = 1, Overseas Transactions Message Indicator: Code that indicates whether the functionality to send message alerts for overseas transactions is active. An overseas transaction is an approved authorization for a transaction in which the merchant country code and issuer country code are different.  Values are: 0 = Inactive, 1 = Active
	// Max Length: 1
	// Min Length: 0
	OtaSmsInd *string `json:"otaSmsInd,omitempty"`

	//  Max length = 13, Overseas Transactions Threshold: An overseas transaction equal to or greater than this amount initiates a text message to the cardholder.
	// Max Length: 13
	// Min Length: 0
	// Pattern: ^[0-9]*$
	OtaThres *string `json:"otaThres,omitempty"`

	//  Max length = 1, Open-To-Buy message indicator The values are: 0 = Inactive, 1 = Active
	// Max Length: 1
	// Min Length: 0
	OtbSmsInd *string `json:"otbSmsInd,omitempty"`

	//  Max length = 11, Open-To-Buy notification threshold: When this field is active, CMS sends a notification when the account's open-to-buy is less than or equal to the value in this field.
	// Max Length: 11
	// Min Length: 0
	// Pattern: ^[0-9]*$
	OtbThres *string `json:"otbThres,omitempty"`

	//  Max length = 17, Maximum amount in monetary units and subunits of OTC cash authorizations allowed for this Embosser record for the frequency defined in the Maximum Frequency fields on the card
	// Pattern: ^(-)?[0-9]{1,17}$
	OtcCashAmount string `json:"otcCashAmount,omitempty"`

	//  Max length = 9, Maximum number of OTC authorizations allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,9}$
	OtcCashNumber string `json:"otcCashNumber,omitempty"`

	//  Max length = 1, Over Limit Alert Opt-in/out Flag: Flag that will indicate account is opted for over limit alert.  Values are:  0 - Alert Option is not opted,  1 - Alert will be sent via SMS,  2 - Alert will be sent via cardholder EMAIL,  3 - Both Email and SMS alert will be sent,  9 - Prefer Product/Logo Level Alert Option
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	OverLmtAlert *string `json:"overLmtAlert,omitempty"`

	//  Max length = 1, Owner/Co-owner indicator: Required if customer record action = A or U. The edits for this field is done in the Add Customer Record Service. The Driver will only edit to be sure that there is a value on the Input. Code that indicates whether to display information for the owner, co-owner, or both on subsequent screens. The values are: 0 = Both owner and co-owner 1 = Owner only (Default) 2 = Co-owner only. This value is not valid in the add mode.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	OwnerCoownerInd *string `json:"ownerCoownerInd,omitempty"`

	//  Max length = 9, Number of the branch that owns account and location of financial reporting for this account.
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	OwningBranch *string `json:"owningBranch,omitempty"`

	//  Max length = 9, Owning store number of the account.
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	OwningStore *string `json:"owningStore,omitempty"`

	// Format: YYYYMMDD. PCT Level Override Expiry Date: Date on which the PCT level override expires. This field is not used if the PCT_OVRD_DMC fields are used
	PctLevelExpirationDate string `json:"pctLevelExpirationDate,omitempty"`

	//  Max length = 1, Code that indicates if a processing control level override is in effect, and if so, the level for the PCT ID in the PricingCtrl field. This field enables you to override the processing control level assigned to the account in the Logo record. Blank = No override in effect (Default) L = Logo O = Organisation S = System The processing control level override is in effect considering StartDate and ExpirationDate. This override is used only for special pricing controls in the PricingCtrl field
	// Max Length: 1
	// Min Length: 0
	PctLevelOverride *string `json:"pctLevelOverride,omitempty"`

	// Format: YYYYMMDD. Date on which the processing control level override starts for the account. The PctLevelOverride field identifies the override level in effect.
	PctLevelStartDate string `json:"pctLevelStartDate,omitempty"`

	//  Max length = 1, Pin Override: Indicates the override action to be taken at the embosser level.   0 - do not use (Default) 1 - do not generate PIN, do not send PIN mailer 2 - generate new PIN and send PIN mailer 3 - send PIN mailer with existing PIN For Magnetic Stripe Cards, the PIN OVERRIDE is set to 0 and the DELAY DAYS value is set to the values defaulted from the Logo record
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	PinOverride *string `json:"pinOverride,omitempty"`

	//  Max length = 1, Pin Suppression Indicator. Flag indicating whether the PIN number and PIN mailer are produced. Values are:  0 - Yes, allow personal identification numbers (PINs),  1 - No, suppress PIN generation
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	PinSuppression *string `json:"pinSuppression,omitempty"`

	//  Max length = 10, Plastic ID: Identifies the plastic stock used to create a card for this Embosser record.
	// Max Length: 10
	// Min Length: 0
	PlasticID *string `json:"plasticId,omitempty"`

	//  Max length = 1, Payment Due Alert opt-in/out Flag: Flag that indicate account is opted for payment due day's alert option.  Values are:  0 - Alert Option is not opted,  1 - Alert will be sent via SMS,  2 - Alert will be sent via cardholder EMAIL,  3 - Both Email and SMS alert will be sent
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	PmtDueAlert *string `json:"pmtDueAlert,omitempty"`

	//  Max length = 2, Payment Due Alert Remainder Days. Values are:  00 -   Payment due remainder days OFF,  00 Thru 15  - Payment due remainder days ON,  99 -   Payment due remainder days ON only Cycle days
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	PmtDueRemDays *string `json:"pmtDueRemDays,omitempty"`

	//  Max length = 3, Code that identifies an existing Processing Control Table (PCT ID) used to establish special pricing controls for the account. The PCT ID in this field determines the Account Control table, Service Charge/Fee table, Insurance table, and Interest tables for the account during the period specified by the StartDate and ExpirationDate fields.
	// Max Length: 3
	// Min Length: 0
	PricingCtrl *string `json:"pricingCtrl,omitempty"`

	//  Max length = 1, Relationship Primary Account Flag: Flag that indicates whether the account is the primary account in the relationship. Values are:  'P' - Primary Account, Space - Not Primary Account
	// Max Length: 1
	// Min Length: 0
	Primary *string `json:"primary,omitempty"`

	//  Max length = 9, ID number of the Smart Card Program. If greater than zero, validate Smart Card Program Definition record is on file. If CardTech TECH = 0 (magnetic strip), ProgramId cannot be greater than zero. If not greater than zero, default program id field on the Logo record is used.
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	ProgramID *string `json:"programId,omitempty"`

	//  Max length = 17, Maximum amount in monetary units and subunits of QUASI CASH authorizations allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,17}$
	QuasiCashAmount string `json:"quasiCashAmount,omitempty"`

	//  Max length = 17, Maximum amount in monetary units and subunits of QUASI CASH authorizations allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,17}$
	QuasiCashAmt string `json:"quasiCashAmt,omitempty"`

	//  Max length = 9, Maximum number of QUASI CASH authorizations allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,9}$
	QuasiCashNbr string `json:"quasiCashNbr,omitempty"`

	//  Max length = 9, Maximum number of QUASI CASH authorizations allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,9}$
	QuasiCashNumber string `json:"quasiCashNumber,omitempty"`

	//  Max length = 9, Branch number that identifies the card mailing location for all  reissued cards when the branch delivery option is used.
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	ReissueBranch *string `json:"reissueBranch,omitempty"`

	//  Max length = 3, Reissue Delivery Option: indicates the delivery option for reissued cards.  Values are:   000 - No special Delivery -   use regular mail (default), 001 - First Class Mail, 002 - Registered Mail, 003 - Internal Delivery Mail, 004 - 999 - User Defined
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	ReissueBranchDelivOption *string `json:"reissueBranchDelivOption,omitempty"`

	//  Max length = 19, Identification number of the Relationship record to which this account is assigned. Complete this field only if assigning the account to a relationship. The Relationship record must be established before you can add an account to the relationship
	// Max Length: 19
	// Min Length: 0
	RelationshipNumber *string `json:"relationshipNumber,omitempty"`

	//  Max length = 3, Code that identifies the state, province, or country in which the account holder resides. For accounts processed by a revolving/  retail product, system uses the residence ID to determine which Processing Control Table identifies the control records that define processing parameters for the account
	// Max Length: 3
	// Min Length: 0
	ResidenceID *string `json:"residenceId,omitempty"`

	//  Max length = 17, Maximum amount in monetary units and subunits of Retail authorizations allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,17}$
	RetailPurchAmount string `json:"retailPurchAmount,omitempty"`

	//  Max length = 9, Maximum number of  Retail authorizations allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,9}$
	RetailPurchNumber string `json:"retailPurchNumber,omitempty"`

	//  Max length = 4, Reward Scheme Identifier: Code that indicates the LMS scheme identifiers assigned to the account.
	// Max Length: 4
	// Min Length: 0
	RewdSchemeIden *string `json:"rewdSchemeIden,omitempty"`

	//  Max length = 6, Sales Executive 1.
	// Max Length: 6
	// Min Length: 0
	SalesExec1 *string `json:"salesExec1,omitempty"`

	//  Max length = 6, Sales Executive 2.
	// Max Length: 6
	// Min Length: 0
	SalesExec2 *string `json:"salesExec2,omitempty"`

	//  Max length = 6, Sales Executive 3.
	// Max Length: 6
	// Min Length: 0
	SalesExec3 *string `json:"salesExec3,omitempty"`

	//  Max length = 1, SDP Process Type: Flag that indicates if the request is for normal processing, Same Day Processing or instant issuance. 0 = Normal processing, 1 = Same day processing, 3 = Instant Issuance
	// Required: true
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SdpProcessType *string `json:"sdpProcessType"`

	//  Max length = 1, Secure Code Activate: Code that indicates whether the account number has had at least one fully authenticated MasterCard SecureCode transaction and is eligible for SecureCode. Values are:  0 - SecureCode is not active for this account  1 - SecureCode is active for this account
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SecurecodeAct *string `json:"securecodeAct,omitempty"`

	//  Max length = 20, Short name of the account holder.  For personal accounts, enter the short name in last name, first name order without punctuation. For business accounts, enter the name of the business. Examples: For the personal account of John H. Watson, type WATSON JOHN H for the short name. For the business account of Dr. John H. Watson, M.D., type DR JOHN H WATSON MD for the short name.
	// Max Length: 20
	// Min Length: 0
	ShortName *string `json:"shortName,omitempty"`

	//  Max length = 16, Self Selected PINBlock
	// Max Length: 16
	// Min Length: 0
	SlfSelPinBlock *string `json:"slfSelPinBlock,omitempty"`

	//  Max length = 1, SMS alerts. The values are: 0 = SMS alert is not active, 1 = SMS alert is active.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SmsAlerts *string `json:"smsAlerts,omitempty"`

	//  Max length = 1, General Banking SMS indicator The values are: 0 = General banking SMS feature is not used (Default), 1 = General banking SMS feature is active and the SMS is sent daily, 2 = General banking SMS feature is active and the SMS is sent weekly (following every Friday night batch run), 3 = General banking SMS feature is active and the SMS is sent monthly, 4 = General banking SMS feature is active and the SMS is sent on every cycle day/statement day.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SmsGenBankingInd *string `json:"smsGenBankingInd,omitempty"`

	//  Max length = 17, Single cash limit set for the embosser.
	// Pattern: ^(-)?[0-9]{1,17}$
	SnglCshLmt string `json:"snglCshLmt,omitempty"`

	// Format: YYYYMMDD. Date when the cash limit was modified.
	SnglDteLmt string `json:"snglDteLmt,omitempty"`

	//  Max length = 20, Source code relating to the promotion or product type for the opening of the account
	// Max Length: 20
	// Min Length: 0
	Source *string `json:"source,omitempty"`

	//  Max length = 1, Source Channel. Values are:  I - Internet, P - Post, T - Telephone, S - Store Default value is 'spaces'
	// Max Length: 1
	// Min Length: 0
	SourceChannel *string `json:"sourceChannel,omitempty"`

	//  Max length = 1, CTD Spend Limit Alert Opt-in/out Flag: Flag that will indicate account is opted for spend limit threshold alert.  Values are:  0 - Alert Option is not opted, 1 - Alert will be sent via SMS,  2 - Alert will be sent via cardholder EMAIL,  3 - Both Email and SMS alert will be sent
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SpndLmtAlert *string `json:"spndLmtAlert,omitempty"`

	//  Max length = 9, Spend Threshold Amount: Amount after which Spend Limit alert is initiated.
	// Max Length: 9
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SpndLmtAmt *string `json:"spndLmtAmt,omitempty"`

	// Format: YYYYMMDD. Date Alternate Customer Start The effective date of the alternate customer address. The default is zeros. The value entered must be a date greater than or equal to the next processing date of the Organisation associated with the account.
	StDte string `json:"stDte,omitempty"`

	//  Max length = 3, State or province of the mailing address for card and PIN mailer
	// Max Length: 3
	// Min Length: 0
	StPr *string `json:"stPr,omitempty"`

	// Format: YYYYMMDD. Date on which the special pricing controls start for the account. The PricingCtrl field identifies the special pricing controls. The StartDate must be equal to or greater than the next processing date.
	StartDate string `json:"startDate,omitempty"`

	//  Max length = 1, Suppress Fee Indicator: Occurrence of the membership fee table amount on the Service Charge/Fee table screen (PRIMARY/1 SUPP-9 SUPP on AZVM02) to be used as the membership fee for the card. The values are: 1 = Second occurrence of the membership fee (Default), 2-9 = Third through tenth occurrence of the membership fee.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SuppFeeInd *string `json:"suppFeeInd,omitempty"`

	// Format: YYYYDDD. Service Fee expiration date: Date on which use of the current fee table override expires. Value must be zeros when Service Charge/Fee table override is not active for the logo
	// Max Length: 7
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SvcFeeExpDt *string `json:"svcFeeExpDt,omitempty"`

	// Format: YYYYDDD. Service Fee start date: Date on which use of the current fee table override started. Value must be zeros when Service Charge/Fee table override is not active for the logo
	// Max Length: 7
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SvcFeeStrtDt *string `json:"svcFeeStrtDt,omitempty"`

	//  Max length = 3, Service Charge/Fee table pointer indicating which override table is to be used.  Value must be zeros when Service Charge/Fee table override is not active for the logo
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SvcFeeTable *string `json:"svcFeeTable,omitempty"`

	//  Max length = 17, Temporary line of credit for the account in whole monetary units. This amount overrides the credit limit assigned to the account . The default is zero.
	// Pattern: ^(-)?[0-9]{1,17}$
	TempCreditLine string `json:"tempCreditLine,omitempty"`

	//  Max length = 4, User-defined code that identifies special terms and conditions which currently apply to the account.
	// Max Length: 4
	// Min Length: 0
	TermCond *string `json:"termCond,omitempty"`

	//  Max length = 17, Maximum amount in monetary units and subunits of total cash authorizations(irrespective of the above channels) allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,17}$
	TotalCashAmt string `json:"totalCashAmt,omitempty"`

	//  Max length = 9, Maximum number of  CASH authorizations(irrespective of the above channels) allowed for the frequency defined in the Frequency field
	// Pattern: ^(-)?[0-9]{1,9}$
	TotalCashNumber string `json:"totalCashNumber,omitempty"`

	//  Max length = 17, Maximum authorization amount in monetary units and subunits for all transactions allowed for the frequency defined in the Frequency field. This amount is inclusive of all Retail, ATM, OTC and Quasi authorizations
	// Pattern: ^(-)?[0-9]{1,17}$
	TotalTxnAmount string `json:"totalTxnAmount,omitempty"`

	//  Max length = 17, Maximum number of authorizations allowed for the frequency defined in the Frequency field. This number is inclusive of all Retail, ATM, OTC and Quasi authorizations
	// Pattern: ^(-)?[0-9]{1,17}$
	TotalTxnNumber string `json:"totalTxnNumber,omitempty"`

	//  Max length = 17, Maximum authorization amount in monetary units and subunits for a single QUASI CASH transaction
	// Pattern: ^(-)?[0-9]{1,17}$
	TransactionLimitQuasi string `json:"transactionLimitQuasi,omitempty"`

	//  Max length = 19, This field is only valid for CustomerRecordAction = 'A'. The Unique ID is passed to VisionPLUS and stored on the customer name and address record as a new field. Unique ID to be available to be maintained through online screens, batch non-monetary updates, and VMx
	// Max Length: 19
	// Min Length: 0
	UniqueID *string `json:"uniqueId,omitempty"`

	//  Max length = 20, User 10 field. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 20
	// Min Length: 0
	User10 *string `json:"user10,omitempty"`

	//  Max length = 19, User 9 field. This field can be defined by each business to store information that is not provided in other fields in the system but still is necessary because of the business processes.
	// Max Length: 19
	// Min Length: 0
	User9 *string `json:"user9,omitempty"`

	//  Max length = 19, User account number
	// Max Length: 19
	// Min Length: 0
	UserAcctNbr *string `json:"userAcctNbr,omitempty"`

	//  Max length = 17, User amount 1
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt1 string `json:"userAmt1,omitempty"`

	//  Max length = 17, User amount 10
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt10 string `json:"userAmt10,omitempty"`

	//  Max length = 17, User amount 11
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt11 string `json:"userAmt11,omitempty"`

	//  Max length = 17, User amount 12
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt12 string `json:"userAmt12,omitempty"`

	//  Max length = 17, User amount 13
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt13 string `json:"userAmt13,omitempty"`

	//  Max length = 17, User amount 14
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt14 string `json:"userAmt14,omitempty"`

	//  Max length = 17, User amount 2
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt2 string `json:"userAmt2,omitempty"`

	//  Max length = 17, User amount 3
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt3 string `json:"userAmt3,omitempty"`

	//  Max length = 17, User amount 4
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt4 string `json:"userAmt4,omitempty"`

	//  Max length = 17, User amount 5
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt5 string `json:"userAmt5,omitempty"`

	//  Max length = 17, User amount 6
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt6 string `json:"userAmt6,omitempty"`

	//  Max length = 17, User amount 7
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt7 string `json:"userAmt7,omitempty"`

	//  Max length = 17, User amount 8
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt8 string `json:"userAmt8,omitempty"`

	//  Max length = 17, User amount 9
	// Pattern: ^(-)?[0-9]{1,17}$
	UserAmt9 string `json:"userAmt9,omitempty"`

	//  Max length = 20, User application data 1
	// Max Length: 20
	// Min Length: 0
	UserAppl1 *string `json:"userAppl1,omitempty"`

	//  Max length = 20, User application data 2
	// Max Length: 20
	// Min Length: 0
	UserAppl2 *string `json:"userAppl2,omitempty"`

	//  Max length = 2, User code 1
	// Max Length: 2
	// Min Length: 0
	UserCode1 *string `json:"userCode1,omitempty"`

	//  Max length = 2, User code 10
	// Max Length: 2
	// Min Length: 0
	UserCode10 *string `json:"userCode10,omitempty"`

	//  Max length = 2, User code 11
	// Max Length: 2
	// Min Length: 0
	UserCode11 *string `json:"userCode11,omitempty"`

	//  Max length = 2, User code 12
	// Max Length: 2
	// Min Length: 0
	UserCode12 *string `json:"userCode12,omitempty"`

	//  Max length = 2, User code13
	// Max Length: 2
	// Min Length: 0
	UserCode13 *string `json:"userCode13,omitempty"`

	//  Max length = 2, User code 14
	// Max Length: 2
	// Min Length: 0
	UserCode14 *string `json:"userCode14,omitempty"`

	//  Max length = 2, User code 2
	// Max Length: 2
	// Min Length: 0
	UserCode2 *string `json:"userCode2,omitempty"`

	//  Max length = 2, User code 3
	// Max Length: 2
	// Min Length: 0
	UserCode3 *string `json:"userCode3,omitempty"`

	//  Max length = 2, User code 4
	// Max Length: 2
	// Min Length: 0
	UserCode4 *string `json:"userCode4,omitempty"`

	//  Max length = 2, User code 5
	// Max Length: 2
	// Min Length: 0
	UserCode5 *string `json:"userCode5,omitempty"`

	//  Max length = 2, User code 6
	// Max Length: 2
	// Min Length: 0
	UserCode6 *string `json:"userCode6,omitempty"`

	//  Max length = 2, User code 7
	// Max Length: 2
	// Min Length: 0
	UserCode7 *string `json:"userCode7,omitempty"`

	//  Max length = 2, User code 8
	// Max Length: 2
	// Min Length: 0
	UserCode8 *string `json:"userCode8,omitempty"`

	//  Max length = 2, User code 9
	// Max Length: 2
	// Min Length: 0
	UserCode9 *string `json:"userCode9,omitempty"`

	// Format: YYYYMMDD. User date 1
	UserDt1 string `json:"userDt1,omitempty"`

	// Format: YYYYMMDD. User date 10
	UserDt10 string `json:"userDt10,omitempty"`

	// Format: YYYYMMDD. User date 11
	UserDt11 string `json:"userDt11,omitempty"`

	// Format: YYYYMMDD. User date 12
	UserDt12 string `json:"userDt12,omitempty"`

	// Format: YYYYMMDD. User date 13
	UserDt13 string `json:"userDt13,omitempty"`

	// Format: YYYYMMDD. User date 14
	UserDt14 string `json:"userDt14,omitempty"`

	// Format: YYYYMMDD. User date 2
	UserDt2 string `json:"userDt2,omitempty"`

	// Format: YYYYMMDD. User date 3
	UserDt3 string `json:"userDt3,omitempty"`

	// Format: YYYYMMDD. User date 4
	UserDt4 string `json:"userDt4,omitempty"`

	// Format: YYYYMMDD. User date 5
	UserDt5 string `json:"userDt5,omitempty"`

	// Format: YYYYMMDD. User date 6
	UserDt6 string `json:"userDt6,omitempty"`

	// Format: YYYYMMDD. User date 7
	UserDt7 string `json:"userDt7,omitempty"`

	// Format: YYYYMMDD. User date 8
	UserDt8 string `json:"userDt8,omitempty"`

	// Format: YYYYMMDD. User date 9
	UserDt9 string `json:"userDt9,omitempty"`

	//  Max length = 1, Flag that indicates if the customer is a very important person (VIP). The values are: 0 = Not a VIP customer (Default) 1 = VIP customer.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	VipStatus *string `json:"vipStatus,omitempty"`

	//  Max length = 1, Supplementary Membership  fee Waiver: Flag that indicates whether to waive all supplemental card membership fees.  Values are:  0 - Do not waive supplemental card membership fees (Default),  1 - Waive supplemental card membership fees.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	WaiveSuppMemFlag *string `json:"waiveSuppMemFlag,omitempty"`

	//  Max length = 7, Membership fee percentage to be waived. The functionality to partially waive the membership fee is not active when the value is zeros. If the value is greater than zeros, the field indicates the percentage of the membership fee waived for the card.
	// Pattern: ^(-)?[0-9]{1,7}$
	WmPercent string `json:"wmPercent,omitempty"`
}

// Validate validates this customer account embosser add request
func (m *CustomerAccountEmbosserAddRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccountLogo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountOrganization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountRecordAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccountType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAcctCtlOvrrd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAcctCustNbrSameInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAcctGenID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAcctLimitCheck(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddressLine1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddressLine2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAltCustNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAltCustNbrFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAnnStmtFlg(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAtmCashAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAtmCashNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAtmDailyAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAtmPckgReq(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthLimitOvrrdFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthMsg(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthThres(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillingLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockCode1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockCode2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBranchNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBureauScr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardActionReason(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardGenID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardStatement(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardTech(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardholderType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCbIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCcdIntCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChanInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientRefInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateColatCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConvChequeOrdering(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConvChqbookDispatchMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCorresCustNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCrdtLmtAlert(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCrdtLmtAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreditLmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCrlimBypsInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustCrlim(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustOrg(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustUcliPref(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerRecordAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCycle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateCardExpr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDcBic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDcGenID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDcIban(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdAchAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdAchReqDay(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdAchType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdBic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdIban(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdNomAchAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdNomAmtPctFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdPayment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdRtBankid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdaAcctNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDdaRtngNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultCashPlan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultPromoPlan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultRetailPlan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryPointSuffix(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDigitalCardInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisabilityInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdGenderCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdUser1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdUser2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdUser3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdUser4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdUser5(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdUser6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdUser7(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdUser8(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbPinCommPref(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbPinMemWord(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbPinMobileNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmblm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbossedName1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbossedName2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbossedNameType1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbossedNameType2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbosserRecordAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbossingCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbossingMail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbossingReq(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbrName1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbrName2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmpID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployeeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFiscalYearEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForeignBilling(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForeignInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFppPlanNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFsFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomeStoreNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomeStoreOrg(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIbsAcctDflt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIbsDdaAcctNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIbsDdaRtngNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIbsSavAcctNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIbsSavRtngNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInHouseScr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIncome(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstCrCardNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstCrFbsc(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstCrNbrGenID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInsuranceProductTable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssuanceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueBranch1st(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIssueDelivOption1st(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLangCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMakerComakerTable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarketingChannelsData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarketingOptOut(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarketingProductsData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemoBillCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemorableWord(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemorableWordReminder(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMini(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscScr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser10(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser11(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser12(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser5(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser7(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser8(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMiscUser9(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobDeviceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobPiAllowed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobProvStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMsCardLogoTable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMultiSchemeCardSetID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNbrCardsRequested(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewAcctCampaign(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOfferCodeOvrd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOfficerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOfflinePin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOndemDcBic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOndemDcIban(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOtaSmsInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOtaThres(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOtbSmsInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOtbThres(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOtcCashAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOtcCashNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverLmtAlert(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwnerCoownerInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwningBranch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwningStore(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePctLevelOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePinOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePinSuppression(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlasticID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePmtDueAlert(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePmtDueRemDays(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePricingCtrl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgramID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuasiCashAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuasiCashAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuasiCashNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuasiCashNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReissueBranch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReissueBranchDelivOption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRelationshipNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResidenceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetailPurchAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetailPurchNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRewdSchemeIden(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSalesExec1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSalesExec2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSalesExec3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSdpProcessType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurecodeAct(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShortName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSlfSelPinBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSmsAlerts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSmsGenBankingInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnglCshLmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceChannel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpndLmtAlert(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpndLmtAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStPr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuppFeeInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvcFeeExpDt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvcFeeStrtDt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSvcFeeTable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTempCreditLine(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTermCond(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalCashAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalCashNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalTxnAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalTxnNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionLimitQuasi(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUniqueID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser10(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser9(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAcctNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt10(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt11(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt12(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt13(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt14(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt5(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt7(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt8(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAmt9(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAppl1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAppl2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode10(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode11(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode12(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode13(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode14(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode5(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode7(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode8(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserCode9(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVipStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWaiveSuppMemFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWmPercent(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAccountLogo(formats strfmt.Registry) error {

	if swag.IsZero(m.AccountLogo) { // not required
		return nil
	}

	if err := validate.MinLength("accountLogo", "body", string(*m.AccountLogo), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("accountLogo", "body", string(*m.AccountLogo), 3); err != nil {
		return err
	}

	if err := validate.Pattern("accountLogo", "body", string(*m.AccountLogo), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAccountNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.AccountNumber) { // not required
		return nil
	}

	if err := validate.MinLength("accountNumber", "body", string(*m.AccountNumber), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("accountNumber", "body", string(*m.AccountNumber), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAccountOrganization(formats strfmt.Registry) error {

	if swag.IsZero(m.AccountOrganization) { // not required
		return nil
	}

	if err := validate.MinLength("accountOrganization", "body", string(*m.AccountOrganization), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("accountOrganization", "body", string(*m.AccountOrganization), 3); err != nil {
		return err
	}

	if err := validate.Pattern("accountOrganization", "body", string(*m.AccountOrganization), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAccountRecordAction(formats strfmt.Registry) error {

	if swag.IsZero(m.AccountRecordAction) { // not required
		return nil
	}

	if err := validate.MinLength("accountRecordAction", "body", string(*m.AccountRecordAction), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("accountRecordAction", "body", string(*m.AccountRecordAction), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAccountType(formats strfmt.Registry) error {

	if swag.IsZero(m.AccountType) { // not required
		return nil
	}

	if err := validate.MinLength("accountType", "body", string(*m.AccountType), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("accountType", "body", string(*m.AccountType), 1); err != nil {
		return err
	}

	if err := validate.Pattern("accountType", "body", string(*m.AccountType), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAcctCtlOvrrd(formats strfmt.Registry) error {

	if swag.IsZero(m.AcctCtlOvrrd) { // not required
		return nil
	}

	if err := validate.MinLength("acctCtlOvrrd", "body", string(*m.AcctCtlOvrrd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("acctCtlOvrrd", "body", string(*m.AcctCtlOvrrd), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAcctCustNbrSameInd(formats strfmt.Registry) error {

	if swag.IsZero(m.AcctCustNbrSameInd) { // not required
		return nil
	}

	if err := validate.MinLength("acctCustNbrSameInd", "body", string(*m.AcctCustNbrSameInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("acctCustNbrSameInd", "body", string(*m.AcctCustNbrSameInd), 1); err != nil {
		return err
	}

	if err := validate.Pattern("acctCustNbrSameInd", "body", string(*m.AcctCustNbrSameInd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAcctGenID(formats strfmt.Registry) error {

	if swag.IsZero(m.AcctGenID) { // not required
		return nil
	}

	if err := validate.MinLength("acctGenId", "body", string(*m.AcctGenID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("acctGenId", "body", string(*m.AcctGenID), 8); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAcctLimitCheck(formats strfmt.Registry) error {

	if swag.IsZero(m.AcctLimitCheck) { // not required
		return nil
	}

	if err := validate.MinLength("acctLimitCheck", "body", string(*m.AcctLimitCheck), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("acctLimitCheck", "body", string(*m.AcctLimitCheck), 1); err != nil {
		return err
	}

	if err := validate.Pattern("acctLimitCheck", "body", string(*m.AcctLimitCheck), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAction(formats strfmt.Registry) error {

	if swag.IsZero(m.Action) { // not required
		return nil
	}

	if err := validate.MinLength("action", "body", string(*m.Action), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("action", "body", string(*m.Action), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAddressLine1(formats strfmt.Registry) error {

	if swag.IsZero(m.AddressLine1) { // not required
		return nil
	}

	if err := validate.MinLength("addressLine1", "body", string(*m.AddressLine1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("addressLine1", "body", string(*m.AddressLine1), 40); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAddressLine2(formats strfmt.Registry) error {

	if swag.IsZero(m.AddressLine2) { // not required
		return nil
	}

	if err := validate.MinLength("addressLine2", "body", string(*m.AddressLine2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("addressLine2", "body", string(*m.AddressLine2), 40); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAltCustNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.AltCustNbr) { // not required
		return nil
	}

	if err := validate.MinLength("altCustNbr", "body", string(*m.AltCustNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("altCustNbr", "body", string(*m.AltCustNbr), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAltCustNbrFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.AltCustNbrFlag) { // not required
		return nil
	}

	if err := validate.MinLength("altCustNbrFlag", "body", string(*m.AltCustNbrFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("altCustNbrFlag", "body", string(*m.AltCustNbrFlag), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAnnStmtFlg(formats strfmt.Registry) error {

	if swag.IsZero(m.AnnStmtFlg) { // not required
		return nil
	}

	if err := validate.MinLength("annStmtFlg", "body", string(*m.AnnStmtFlg), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("annStmtFlg", "body", string(*m.AnnStmtFlg), 1); err != nil {
		return err
	}

	if err := validate.Pattern("annStmtFlg", "body", string(*m.AnnStmtFlg), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAtmCashAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.AtmCashAmount) { // not required
		return nil
	}

	if err := validate.Pattern("atmCashAmount", "body", string(m.AtmCashAmount), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAtmCashNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.AtmCashNumber) { // not required
		return nil
	}

	if err := validate.Pattern("atmCashNumber", "body", string(m.AtmCashNumber), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAtmDailyAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.AtmDailyAmount) { // not required
		return nil
	}

	if err := validate.Pattern("atmDailyAmount", "body", string(m.AtmDailyAmount), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAtmPckgReq(formats strfmt.Registry) error {

	if swag.IsZero(m.AtmPckgReq) { // not required
		return nil
	}

	if err := validate.MinLength("atmPckgReq", "body", string(*m.AtmPckgReq), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("atmPckgReq", "body", string(*m.AtmPckgReq), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAuthLimitOvrrdFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthLimitOvrrdFlag) { // not required
		return nil
	}

	if err := validate.MinLength("authLimitOvrrdFlag", "body", string(*m.AuthLimitOvrrdFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("authLimitOvrrdFlag", "body", string(*m.AuthLimitOvrrdFlag), 1); err != nil {
		return err
	}

	if err := validate.Pattern("authLimitOvrrdFlag", "body", string(*m.AuthLimitOvrrdFlag), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAuthMsg(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthMsg) { // not required
		return nil
	}

	if err := validate.MinLength("authMsg", "body", string(*m.AuthMsg), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("authMsg", "body", string(*m.AuthMsg), 1); err != nil {
		return err
	}

	if err := validate.Pattern("authMsg", "body", string(*m.AuthMsg), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateAuthThres(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthThres) { // not required
		return nil
	}

	if err := validate.MinLength("authThres", "body", string(*m.AuthThres), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("authThres", "body", string(*m.AuthThres), 9); err != nil {
		return err
	}

	if err := validate.Pattern("authThres", "body", string(*m.AuthThres), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateBankCode(formats strfmt.Registry) error {

	if swag.IsZero(m.BankCode) { // not required
		return nil
	}

	if err := validate.MinLength("bankCode", "body", string(*m.BankCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("bankCode", "body", string(*m.BankCode), 4); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateBillingLevel(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingLevel) { // not required
		return nil
	}

	if err := validate.MinLength("billingLevel", "body", string(*m.BillingLevel), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("billingLevel", "body", string(*m.BillingLevel), 1); err != nil {
		return err
	}

	if err := validate.Pattern("billingLevel", "body", string(*m.BillingLevel), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateBlockCode(formats strfmt.Registry) error {

	if swag.IsZero(m.BlockCode) { // not required
		return nil
	}

	if err := validate.MinLength("blockCode", "body", string(*m.BlockCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("blockCode", "body", string(*m.BlockCode), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateBlockCode1(formats strfmt.Registry) error {

	if swag.IsZero(m.BlockCode1) { // not required
		return nil
	}

	if err := validate.MinLength("blockCode1", "body", string(*m.BlockCode1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("blockCode1", "body", string(*m.BlockCode1), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateBlockCode2(formats strfmt.Registry) error {

	if swag.IsZero(m.BlockCode2) { // not required
		return nil
	}

	if err := validate.MinLength("blockCode2", "body", string(*m.BlockCode2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("blockCode2", "body", string(*m.BlockCode2), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateBranchNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.BranchNumber) { // not required
		return nil
	}

	if err := validate.MinLength("branchNumber", "body", string(*m.BranchNumber), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("branchNumber", "body", string(*m.BranchNumber), 9); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateBureauScr(formats strfmt.Registry) error {

	if swag.IsZero(m.BureauScr) { // not required
		return nil
	}

	if err := validate.Pattern("bureauScr", "body", string(m.BureauScr), `^(-)?[0-9]{1,5}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCardActionReason(formats strfmt.Registry) error {

	if swag.IsZero(m.CardActionReason) { // not required
		return nil
	}

	if err := validate.MinLength("cardActionReason", "body", string(*m.CardActionReason), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardActionReason", "body", string(*m.CardActionReason), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCardGenID(formats strfmt.Registry) error {

	if swag.IsZero(m.CardGenID) { // not required
		return nil
	}

	if err := validate.MinLength("cardGenId", "body", string(*m.CardGenID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardGenId", "body", string(*m.CardGenID), 8); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCardStatement(formats strfmt.Registry) error {

	if swag.IsZero(m.CardStatement) { // not required
		return nil
	}

	if err := validate.MinLength("cardStatement", "body", string(*m.CardStatement), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardStatement", "body", string(*m.CardStatement), 1); err != nil {
		return err
	}

	if err := validate.Pattern("cardStatement", "body", string(*m.CardStatement), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCardTech(formats strfmt.Registry) error {

	if swag.IsZero(m.CardTech) { // not required
		return nil
	}

	if err := validate.MinLength("cardTech", "body", string(*m.CardTech), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardTech", "body", string(*m.CardTech), 1); err != nil {
		return err
	}

	if err := validate.Pattern("cardTech", "body", string(*m.CardTech), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCardholderType(formats strfmt.Registry) error {

	if swag.IsZero(m.CardholderType) { // not required
		return nil
	}

	if err := validate.MinLength("cardholderType", "body", string(*m.CardholderType), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardholderType", "body", string(*m.CardholderType), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCbIndicator(formats strfmt.Registry) error {

	if swag.IsZero(m.CbIndicator) { // not required
		return nil
	}

	if err := validate.MinLength("cbIndicator", "body", string(*m.CbIndicator), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cbIndicator", "body", string(*m.CbIndicator), 1); err != nil {
		return err
	}

	if err := validate.Pattern("cbIndicator", "body", string(*m.CbIndicator), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCcdIntCode(formats strfmt.Registry) error {

	if swag.IsZero(m.CcdIntCode) { // not required
		return nil
	}

	if err := validate.MinLength("ccdIntCode", "body", string(*m.CcdIntCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ccdIntCode", "body", string(*m.CcdIntCode), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateChanInd(formats strfmt.Registry) error {

	if swag.IsZero(m.ChanInd) { // not required
		return nil
	}

	if err := validate.MinLength("chanInd", "body", string(*m.ChanInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("chanInd", "body", string(*m.ChanInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateClientRefInd(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientRefInd) { // not required
		return nil
	}

	if err := validate.MinLength("clientRefInd", "body", string(*m.ClientRefInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("clientRefInd", "body", string(*m.ClientRefInd), 40); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateColatCode(formats strfmt.Registry) error {

	if swag.IsZero(m.ColatCode) { // not required
		return nil
	}

	if err := validate.MinLength("colatCode", "body", string(*m.ColatCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("colatCode", "body", string(*m.ColatCode), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCommon(formats strfmt.Registry) error {

	if swag.IsZero(m.Common) { // not required
		return nil
	}

	if m.Common != nil {
		if err := m.Common.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("common")
			}
			return err
		}
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateConvChequeOrdering(formats strfmt.Registry) error {

	if swag.IsZero(m.ConvChequeOrdering) { // not required
		return nil
	}

	if err := validate.MinLength("convChequeOrdering", "body", string(*m.ConvChequeOrdering), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("convChequeOrdering", "body", string(*m.ConvChequeOrdering), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateConvChqbookDispatchMethod(formats strfmt.Registry) error {

	if swag.IsZero(m.ConvChqbookDispatchMethod) { // not required
		return nil
	}

	if err := validate.MinLength("convChqbookDispatchMethod", "body", string(*m.ConvChqbookDispatchMethod), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("convChqbookDispatchMethod", "body", string(*m.ConvChqbookDispatchMethod), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCorresCustNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.CorresCustNbr) { // not required
		return nil
	}

	if err := validate.MinLength("corresCustNbr", "body", string(*m.CorresCustNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("corresCustNbr", "body", string(*m.CorresCustNbr), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCrdtLmtAlert(formats strfmt.Registry) error {

	if swag.IsZero(m.CrdtLmtAlert) { // not required
		return nil
	}

	if err := validate.MinLength("crdtLmtAlert", "body", string(*m.CrdtLmtAlert), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("crdtLmtAlert", "body", string(*m.CrdtLmtAlert), 1); err != nil {
		return err
	}

	if err := validate.Pattern("crdtLmtAlert", "body", string(*m.CrdtLmtAlert), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCrdtLmtAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.CrdtLmtAmt) { // not required
		return nil
	}

	if err := validate.MinLength("crdtLmtAmt", "body", string(*m.CrdtLmtAmt), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("crdtLmtAmt", "body", string(*m.CrdtLmtAmt), 9); err != nil {
		return err
	}

	if err := validate.Pattern("crdtLmtAmt", "body", string(*m.CrdtLmtAmt), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCreditLmt(formats strfmt.Registry) error {

	if swag.IsZero(m.CreditLmt) { // not required
		return nil
	}

	if err := validate.Pattern("creditLmt", "body", string(m.CreditLmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCrlimBypsInd(formats strfmt.Registry) error {

	if swag.IsZero(m.CrlimBypsInd) { // not required
		return nil
	}

	if err := validate.MinLength("crlimBypsInd", "body", string(*m.CrlimBypsInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("crlimBypsInd", "body", string(*m.CrlimBypsInd), 1); err != nil {
		return err
	}

	if err := validate.Pattern("crlimBypsInd", "body", string(*m.CrlimBypsInd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCustCrlim(formats strfmt.Registry) error {

	if swag.IsZero(m.CustCrlim) { // not required
		return nil
	}

	if err := validate.MinLength("custCrlim", "body", string(*m.CustCrlim), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("custCrlim", "body", string(*m.CustCrlim), 17); err != nil {
		return err
	}

	if err := validate.Pattern("custCrlim", "body", string(*m.CustCrlim), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCustNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.CustNbr) { // not required
		return nil
	}

	if err := validate.MinLength("custNbr", "body", string(*m.CustNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("custNbr", "body", string(*m.CustNbr), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCustOrg(formats strfmt.Registry) error {

	if swag.IsZero(m.CustOrg) { // not required
		return nil
	}

	if err := validate.MinLength("custOrg", "body", string(*m.CustOrg), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("custOrg", "body", string(*m.CustOrg), 3); err != nil {
		return err
	}

	if err := validate.Pattern("custOrg", "body", string(*m.CustOrg), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCustUcliPref(formats strfmt.Registry) error {

	if swag.IsZero(m.CustUcliPref) { // not required
		return nil
	}

	if err := validate.MinLength("custUcliPref", "body", string(*m.CustUcliPref), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("custUcliPref", "body", string(*m.CustUcliPref), 1); err != nil {
		return err
	}

	if err := validate.Pattern("custUcliPref", "body", string(*m.CustUcliPref), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCustomerNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomerNumber) { // not required
		return nil
	}

	if err := validate.MinLength("customerNumber", "body", string(*m.CustomerNumber), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerNumber", "body", string(*m.CustomerNumber), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCustomerRecordAction(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomerRecordAction) { // not required
		return nil
	}

	if err := validate.MinLength("customerRecordAction", "body", string(*m.CustomerRecordAction), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerRecordAction", "body", string(*m.CustomerRecordAction), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateCycle(formats strfmt.Registry) error {

	if swag.IsZero(m.Cycle) { // not required
		return nil
	}

	if err := validate.MinLength("cycle", "body", string(*m.Cycle), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cycle", "body", string(*m.Cycle), 2); err != nil {
		return err
	}

	if err := validate.Pattern("cycle", "body", string(*m.Cycle), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDateCardExpr(formats strfmt.Registry) error {

	if swag.IsZero(m.DateCardExpr) { // not required
		return nil
	}

	if err := validate.MinLength("dateCardExpr", "body", string(*m.DateCardExpr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("dateCardExpr", "body", string(*m.DateCardExpr), 4); err != nil {
		return err
	}

	if err := validate.Pattern("dateCardExpr", "body", string(*m.DateCardExpr), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDcBic(formats strfmt.Registry) error {

	if swag.IsZero(m.DcBic) { // not required
		return nil
	}

	if err := validate.MinLength("dcBic", "body", string(*m.DcBic), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("dcBic", "body", string(*m.DcBic), 11); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDcGenID(formats strfmt.Registry) error {

	if swag.IsZero(m.DcGenID) { // not required
		return nil
	}

	if err := validate.MinLength("dcGenId", "body", string(*m.DcGenID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("dcGenId", "body", string(*m.DcGenID), 8); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDcIban(formats strfmt.Registry) error {

	if swag.IsZero(m.DcIban) { // not required
		return nil
	}

	if err := validate.MinLength("dcIban", "body", string(*m.DcIban), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("dcIban", "body", string(*m.DcIban), 34); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdAchAccountNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.DdAchAccountNumber) { // not required
		return nil
	}

	if err := validate.MinLength("ddAchAccountNumber", "body", string(*m.DdAchAccountNumber), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddAchAccountNumber", "body", string(*m.DdAchAccountNumber), 17); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdAchReqDay(formats strfmt.Registry) error {

	if swag.IsZero(m.DdAchReqDay) { // not required
		return nil
	}

	if err := validate.MinLength("ddAchReqDay", "body", string(*m.DdAchReqDay), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddAchReqDay", "body", string(*m.DdAchReqDay), 2); err != nil {
		return err
	}

	if err := validate.Pattern("ddAchReqDay", "body", string(*m.DdAchReqDay), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdAchType(formats strfmt.Registry) error {

	if swag.IsZero(m.DdAchType) { // not required
		return nil
	}

	if err := validate.MinLength("ddAchType", "body", string(*m.DdAchType), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddAchType", "body", string(*m.DdAchType), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdBic(formats strfmt.Registry) error {

	if swag.IsZero(m.DdBic) { // not required
		return nil
	}

	if err := validate.MinLength("ddBic", "body", string(*m.DdBic), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddBic", "body", string(*m.DdBic), 11); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdIban(formats strfmt.Registry) error {

	if swag.IsZero(m.DdIban) { // not required
		return nil
	}

	if err := validate.MinLength("ddIban", "body", string(*m.DdIban), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddIban", "body", string(*m.DdIban), 34); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdNomAchAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.DdNomAchAmt) { // not required
		return nil
	}

	if err := validate.Pattern("ddNomAchAmt", "body", string(m.DdNomAchAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdNomAmtPctFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.DdNomAmtPctFlag) { // not required
		return nil
	}

	if err := validate.MinLength("ddNomAmtPctFlag", "body", string(*m.DdNomAmtPctFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddNomAmtPctFlag", "body", string(*m.DdNomAmtPctFlag), 1); err != nil {
		return err
	}

	if err := validate.Pattern("ddNomAmtPctFlag", "body", string(*m.DdNomAmtPctFlag), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdPayment(formats strfmt.Registry) error {

	if swag.IsZero(m.DdPayment) { // not required
		return nil
	}

	if err := validate.MinLength("ddPayment", "body", string(*m.DdPayment), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddPayment", "body", string(*m.DdPayment), 1); err != nil {
		return err
	}

	if err := validate.Pattern("ddPayment", "body", string(*m.DdPayment), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdRtBankid(formats strfmt.Registry) error {

	if swag.IsZero(m.DdRtBankid) { // not required
		return nil
	}

	if err := validate.MinLength("ddRtBankid", "body", string(*m.DdRtBankid), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddRtBankid", "body", string(*m.DdRtBankid), 10); err != nil {
		return err
	}

	if err := validate.Pattern("ddRtBankid", "body", string(*m.DdRtBankid), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdaAcctNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.DdaAcctNbr) { // not required
		return nil
	}

	if err := validate.MinLength("ddaAcctNbr", "body", string(*m.DdaAcctNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddaAcctNbr", "body", string(*m.DdaAcctNbr), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDdaRtngNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.DdaRtngNbr) { // not required
		return nil
	}

	if err := validate.MinLength("ddaRtngNbr", "body", string(*m.DdaRtngNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ddaRtngNbr", "body", string(*m.DdaRtngNbr), 9); err != nil {
		return err
	}

	if err := validate.Pattern("ddaRtngNbr", "body", string(*m.DdaRtngNbr), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDefaultCashPlan(formats strfmt.Registry) error {

	if swag.IsZero(m.DefaultCashPlan) { // not required
		return nil
	}

	if err := validate.MinLength("defaultCashPlan", "body", string(*m.DefaultCashPlan), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("defaultCashPlan", "body", string(*m.DefaultCashPlan), 5); err != nil {
		return err
	}

	if err := validate.Pattern("defaultCashPlan", "body", string(*m.DefaultCashPlan), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDefaultPromoPlan(formats strfmt.Registry) error {

	if swag.IsZero(m.DefaultPromoPlan) { // not required
		return nil
	}

	if err := validate.MinLength("defaultPromoPlan", "body", string(*m.DefaultPromoPlan), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("defaultPromoPlan", "body", string(*m.DefaultPromoPlan), 5); err != nil {
		return err
	}

	if err := validate.Pattern("defaultPromoPlan", "body", string(*m.DefaultPromoPlan), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDefaultRetailPlan(formats strfmt.Registry) error {

	if swag.IsZero(m.DefaultRetailPlan) { // not required
		return nil
	}

	if err := validate.MinLength("defaultRetailPlan", "body", string(*m.DefaultRetailPlan), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("defaultRetailPlan", "body", string(*m.DefaultRetailPlan), 5); err != nil {
		return err
	}

	if err := validate.Pattern("defaultRetailPlan", "body", string(*m.DefaultRetailPlan), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDeliveryPointSuffix(formats strfmt.Registry) error {

	if swag.IsZero(m.DeliveryPointSuffix) { // not required
		return nil
	}

	if err := validate.MinLength("deliveryPointSuffix", "body", string(*m.DeliveryPointSuffix), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("deliveryPointSuffix", "body", string(*m.DeliveryPointSuffix), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDigitalCardInd(formats strfmt.Registry) error {

	if swag.IsZero(m.DigitalCardInd) { // not required
		return nil
	}

	if err := validate.MinLength("digitalCardInd", "body", string(*m.DigitalCardInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("digitalCardInd", "body", string(*m.DigitalCardInd), 1); err != nil {
		return err
	}

	if err := validate.Pattern("digitalCardInd", "body", string(*m.DigitalCardInd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDisabilityInd(formats strfmt.Registry) error {

	if swag.IsZero(m.DisabilityInd) { // not required
		return nil
	}

	if err := validate.MinLength("disabilityInd", "body", string(*m.DisabilityInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("disabilityInd", "body", string(*m.DisabilityInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateDue(formats strfmt.Registry) error {

	if swag.IsZero(m.Due) { // not required
		return nil
	}

	if err := validate.MinLength("due", "body", string(*m.Due), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("due", "body", string(*m.Due), 2); err != nil {
		return err
	}

	if err := validate.Pattern("due", "body", string(*m.Due), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdGenderCode(formats strfmt.Registry) error {

	if swag.IsZero(m.EdGenderCode) { // not required
		return nil
	}

	if err := validate.MinLength("edGenderCode", "body", string(*m.EdGenderCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edGenderCode", "body", string(*m.EdGenderCode), 1); err != nil {
		return err
	}

	if err := validate.Pattern("edGenderCode", "body", string(*m.EdGenderCode), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdPostalCode(formats strfmt.Registry) error {

	if swag.IsZero(m.EdPostalCode) { // not required
		return nil
	}

	if err := validate.MinLength("edPostalCode", "body", string(*m.EdPostalCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edPostalCode", "body", string(*m.EdPostalCode), 10); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdUser1(formats strfmt.Registry) error {

	if swag.IsZero(m.EdUser1) { // not required
		return nil
	}

	if err := validate.MinLength("edUser1", "body", string(*m.EdUser1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edUser1", "body", string(*m.EdUser1), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdUser2(formats strfmt.Registry) error {

	if swag.IsZero(m.EdUser2) { // not required
		return nil
	}

	if err := validate.MinLength("edUser2", "body", string(*m.EdUser2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edUser2", "body", string(*m.EdUser2), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdUser3(formats strfmt.Registry) error {

	if swag.IsZero(m.EdUser3) { // not required
		return nil
	}

	if err := validate.MinLength("edUser3", "body", string(*m.EdUser3), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edUser3", "body", string(*m.EdUser3), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdUser4(formats strfmt.Registry) error {

	if swag.IsZero(m.EdUser4) { // not required
		return nil
	}

	if err := validate.MinLength("edUser4", "body", string(*m.EdUser4), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edUser4", "body", string(*m.EdUser4), 4); err != nil {
		return err
	}

	if err := validate.Pattern("edUser4", "body", string(*m.EdUser4), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdUser5(formats strfmt.Registry) error {

	if swag.IsZero(m.EdUser5) { // not required
		return nil
	}

	if err := validate.MinLength("edUser5", "body", string(*m.EdUser5), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edUser5", "body", string(*m.EdUser5), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdUser6(formats strfmt.Registry) error {

	if swag.IsZero(m.EdUser6) { // not required
		return nil
	}

	if err := validate.MinLength("edUser6", "body", string(*m.EdUser6), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edUser6", "body", string(*m.EdUser6), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdUser7(formats strfmt.Registry) error {

	if swag.IsZero(m.EdUser7) { // not required
		return nil
	}

	if err := validate.MinLength("edUser7", "body", string(*m.EdUser7), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edUser7", "body", string(*m.EdUser7), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEdUser8(formats strfmt.Registry) error {

	if swag.IsZero(m.EdUser8) { // not required
		return nil
	}

	if err := validate.MinLength("edUser8", "body", string(*m.EdUser8), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("edUser8", "body", string(*m.EdUser8), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbCity(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbCity) { // not required
		return nil
	}

	if err := validate.MinLength("embCity", "body", string(*m.EmbCity), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embCity", "body", string(*m.EmbCity), 30); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbPinCommPref(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbPinCommPref) { // not required
		return nil
	}

	if err := validate.MinLength("embPinCommPref", "body", string(*m.EmbPinCommPref), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embPinCommPref", "body", string(*m.EmbPinCommPref), 1); err != nil {
		return err
	}

	if err := validate.Pattern("embPinCommPref", "body", string(*m.EmbPinCommPref), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbPinMemWord(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbPinMemWord) { // not required
		return nil
	}

	if err := validate.MinLength("embPinMemWord", "body", string(*m.EmbPinMemWord), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embPinMemWord", "body", string(*m.EmbPinMemWord), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbPinMobileNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbPinMobileNbr) { // not required
		return nil
	}

	if err := validate.MinLength("embPinMobileNbr", "body", string(*m.EmbPinMobileNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embPinMobileNbr", "body", string(*m.EmbPinMobileNbr), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmblm(formats strfmt.Registry) error {

	if swag.IsZero(m.Emblm) { // not required
		return nil
	}

	if err := validate.MinLength("emblm", "body", string(*m.Emblm), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("emblm", "body", string(*m.Emblm), 5); err != nil {
		return err
	}

	if err := validate.Pattern("emblm", "body", string(*m.Emblm), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbossedName1(formats strfmt.Registry) error {

	if err := validate.Required("embossedName1", "body", m.EmbossedName1); err != nil {
		return err
	}

	if err := validate.MinLength("embossedName1", "body", string(*m.EmbossedName1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embossedName1", "body", string(*m.EmbossedName1), 26); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbossedName2(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbossedName2) { // not required
		return nil
	}

	if err := validate.MinLength("embossedName2", "body", string(*m.EmbossedName2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embossedName2", "body", string(*m.EmbossedName2), 26); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbossedNameType1(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbossedNameType1) { // not required
		return nil
	}

	if err := validate.MinLength("embossedNameType1", "body", string(*m.EmbossedNameType1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embossedNameType1", "body", string(*m.EmbossedNameType1), 1); err != nil {
		return err
	}

	if err := validate.Pattern("embossedNameType1", "body", string(*m.EmbossedNameType1), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbossedNameType2(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbossedNameType2) { // not required
		return nil
	}

	if err := validate.MinLength("embossedNameType2", "body", string(*m.EmbossedNameType2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embossedNameType2", "body", string(*m.EmbossedNameType2), 1); err != nil {
		return err
	}

	if err := validate.Pattern("embossedNameType2", "body", string(*m.EmbossedNameType2), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbosserRecordAction(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbosserRecordAction) { // not required
		return nil
	}

	if err := validate.MinLength("embosserRecordAction", "body", string(*m.EmbosserRecordAction), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embosserRecordAction", "body", string(*m.EmbosserRecordAction), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbossingCard(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbossingCard) { // not required
		return nil
	}

	if err := validate.MinLength("embossingCard", "body", string(*m.EmbossingCard), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embossingCard", "body", string(*m.EmbossingCard), 2); err != nil {
		return err
	}

	if err := validate.Pattern("embossingCard", "body", string(*m.EmbossingCard), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbossingMail(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbossingMail) { // not required
		return nil
	}

	if err := validate.MinLength("embossingMail", "body", string(*m.EmbossingMail), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embossingMail", "body", string(*m.EmbossingMail), 2); err != nil {
		return err
	}

	if err := validate.Pattern("embossingMail", "body", string(*m.EmbossingMail), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbossingReq(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbossingReq) { // not required
		return nil
	}

	if err := validate.MinLength("embossingReq", "body", string(*m.EmbossingReq), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embossingReq", "body", string(*m.EmbossingReq), 2); err != nil {
		return err
	}

	if err := validate.Pattern("embossingReq", "body", string(*m.EmbossingReq), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbrName1(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbrName1) { // not required
		return nil
	}

	if err := validate.MinLength("embrName1", "body", string(*m.EmbrName1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embrName1", "body", string(*m.EmbrName1), 40); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmbrName2(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbrName2) { // not required
		return nil
	}

	if err := validate.MinLength("embrName2", "body", string(*m.EmbrName2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embrName2", "body", string(*m.EmbrName2), 40); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmpID(formats strfmt.Registry) error {

	if swag.IsZero(m.EmpID) { // not required
		return nil
	}

	if err := validate.MinLength("empId", "body", string(*m.EmpID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("empId", "body", string(*m.EmpID), 15); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateEmployeeCode(formats strfmt.Registry) error {

	if swag.IsZero(m.EmployeeCode) { // not required
		return nil
	}

	if err := validate.MinLength("employeeCode", "body", string(*m.EmployeeCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("employeeCode", "body", string(*m.EmployeeCode), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateFiscalYearEnd(formats strfmt.Registry) error {

	if swag.IsZero(m.FiscalYearEnd) { // not required
		return nil
	}

	if err := validate.MinLength("fiscalYearEnd", "body", string(*m.FiscalYearEnd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("fiscalYearEnd", "body", string(*m.FiscalYearEnd), 2); err != nil {
		return err
	}

	if err := validate.Pattern("fiscalYearEnd", "body", string(*m.FiscalYearEnd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateForeignBilling(formats strfmt.Registry) error {

	if swag.IsZero(m.ForeignBilling) { // not required
		return nil
	}

	if err := validate.MinLength("foreignBilling", "body", string(*m.ForeignBilling), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("foreignBilling", "body", string(*m.ForeignBilling), 1); err != nil {
		return err
	}

	if err := validate.Pattern("foreignBilling", "body", string(*m.ForeignBilling), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateForeignInd(formats strfmt.Registry) error {

	if swag.IsZero(m.ForeignInd) { // not required
		return nil
	}

	if err := validate.MinLength("foreignInd", "body", string(*m.ForeignInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("foreignInd", "body", string(*m.ForeignInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateFppPlanNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.FppPlanNbr) { // not required
		return nil
	}

	if err := validate.MinLength("fppPlanNbr", "body", string(*m.FppPlanNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("fppPlanNbr", "body", string(*m.FppPlanNbr), 5); err != nil {
		return err
	}

	if err := validate.Pattern("fppPlanNbr", "body", string(*m.FppPlanNbr), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateFrequency(formats strfmt.Registry) error {

	if swag.IsZero(m.Frequency) { // not required
		return nil
	}

	if err := validate.MinLength("frequency", "body", string(*m.Frequency), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("frequency", "body", string(*m.Frequency), 1); err != nil {
		return err
	}

	if err := validate.Pattern("frequency", "body", string(*m.Frequency), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateFsFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.FsFlag) { // not required
		return nil
	}

	if err := validate.MinLength("fsFlag", "body", string(*m.FsFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("fsFlag", "body", string(*m.FsFlag), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateHomeStoreNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.HomeStoreNbr) { // not required
		return nil
	}

	if err := validate.MinLength("homeStoreNbr", "body", string(*m.HomeStoreNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("homeStoreNbr", "body", string(*m.HomeStoreNbr), 9); err != nil {
		return err
	}

	if err := validate.Pattern("homeStoreNbr", "body", string(*m.HomeStoreNbr), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateHomeStoreOrg(formats strfmt.Registry) error {

	if swag.IsZero(m.HomeStoreOrg) { // not required
		return nil
	}

	if err := validate.MinLength("homeStoreOrg", "body", string(*m.HomeStoreOrg), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("homeStoreOrg", "body", string(*m.HomeStoreOrg), 3); err != nil {
		return err
	}

	if err := validate.Pattern("homeStoreOrg", "body", string(*m.HomeStoreOrg), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateIbsAcctDflt(formats strfmt.Registry) error {

	if swag.IsZero(m.IbsAcctDflt) { // not required
		return nil
	}

	if err := validate.MinLength("ibsAcctDflt", "body", string(*m.IbsAcctDflt), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ibsAcctDflt", "body", string(*m.IbsAcctDflt), 2); err != nil {
		return err
	}

	if err := validate.Pattern("ibsAcctDflt", "body", string(*m.IbsAcctDflt), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateIbsDdaAcctNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.IbsDdaAcctNbr) { // not required
		return nil
	}

	if err := validate.MinLength("ibsDdaAcctNbr", "body", string(*m.IbsDdaAcctNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ibsDdaAcctNbr", "body", string(*m.IbsDdaAcctNbr), 17); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateIbsDdaRtngNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.IbsDdaRtngNbr) { // not required
		return nil
	}

	if err := validate.MinLength("ibsDdaRtngNbr", "body", string(*m.IbsDdaRtngNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ibsDdaRtngNbr", "body", string(*m.IbsDdaRtngNbr), 10); err != nil {
		return err
	}

	if err := validate.Pattern("ibsDdaRtngNbr", "body", string(*m.IbsDdaRtngNbr), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateIbsSavAcctNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.IbsSavAcctNbr) { // not required
		return nil
	}

	if err := validate.MinLength("ibsSavAcctNbr", "body", string(*m.IbsSavAcctNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ibsSavAcctNbr", "body", string(*m.IbsSavAcctNbr), 17); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateIbsSavRtngNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.IbsSavRtngNbr) { // not required
		return nil
	}

	if err := validate.MinLength("ibsSavRtngNbr", "body", string(*m.IbsSavRtngNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ibsSavRtngNbr", "body", string(*m.IbsSavRtngNbr), 10); err != nil {
		return err
	}

	if err := validate.Pattern("ibsSavRtngNbr", "body", string(*m.IbsSavRtngNbr), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateInHouseScr(formats strfmt.Registry) error {

	if swag.IsZero(m.InHouseScr) { // not required
		return nil
	}

	if err := validate.Pattern("inHouseScr", "body", string(m.InHouseScr), `^(-)?[0-9]{1,5}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateIncome(formats strfmt.Registry) error {

	if swag.IsZero(m.Income) { // not required
		return nil
	}

	if err := validate.Pattern("income", "body", string(m.Income), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateInstCrCardNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.InstCrCardNbr) { // not required
		return nil
	}

	if err := validate.MinLength("instCrCardNbr", "body", string(*m.InstCrCardNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("instCrCardNbr", "body", string(*m.InstCrCardNbr), 16); err != nil {
		return err
	}

	if err := validate.Pattern("instCrCardNbr", "body", string(*m.InstCrCardNbr), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateInstCrFbsc(formats strfmt.Registry) error {

	if swag.IsZero(m.InstCrFbsc) { // not required
		return nil
	}

	if err := validate.MinLength("instCrFbsc", "body", string(*m.InstCrFbsc), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("instCrFbsc", "body", string(*m.InstCrFbsc), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateInstCrNbrGenID(formats strfmt.Registry) error {

	if swag.IsZero(m.InstCrNbrGenID) { // not required
		return nil
	}

	if err := validate.MinLength("instCrNbrGenId", "body", string(*m.InstCrNbrGenID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("instCrNbrGenId", "body", string(*m.InstCrNbrGenID), 8); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateInsuranceProductTable(formats strfmt.Registry) error {

	if swag.IsZero(m.InsuranceProductTable) { // not required
		return nil
	}

	for i := 0; i < len(m.InsuranceProductTable); i++ {
		if swag.IsZero(m.InsuranceProductTable[i]) { // not required
			continue
		}

		if m.InsuranceProductTable[i] != nil {
			if err := m.InsuranceProductTable[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("insuranceProductTable" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateIssuanceID(formats strfmt.Registry) error {

	if swag.IsZero(m.IssuanceID) { // not required
		return nil
	}

	if err := validate.MinLength("issuanceId", "body", string(*m.IssuanceID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("issuanceId", "body", string(*m.IssuanceID), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateIssueBranch1st(formats strfmt.Registry) error {

	if swag.IsZero(m.IssueBranch1st) { // not required
		return nil
	}

	if err := validate.MinLength("issueBranch1st", "body", string(*m.IssueBranch1st), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("issueBranch1st", "body", string(*m.IssueBranch1st), 9); err != nil {
		return err
	}

	if err := validate.Pattern("issueBranch1st", "body", string(*m.IssueBranch1st), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateIssueDelivOption1st(formats strfmt.Registry) error {

	if swag.IsZero(m.IssueDelivOption1st) { // not required
		return nil
	}

	if err := validate.MinLength("issueDelivOption1st", "body", string(*m.IssueDelivOption1st), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("issueDelivOption1st", "body", string(*m.IssueDelivOption1st), 3); err != nil {
		return err
	}

	if err := validate.Pattern("issueDelivOption1st", "body", string(*m.IssueDelivOption1st), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateLangCode(formats strfmt.Registry) error {

	if swag.IsZero(m.LangCode) { // not required
		return nil
	}

	if err := validate.MinLength("langCode", "body", string(*m.LangCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("langCode", "body", string(*m.LangCode), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMakerComakerTable(formats strfmt.Registry) error {

	if swag.IsZero(m.MakerComakerTable) { // not required
		return nil
	}

	for i := 0; i < len(m.MakerComakerTable); i++ {
		if swag.IsZero(m.MakerComakerTable[i]) { // not required
			continue
		}

		if m.MakerComakerTable[i] != nil {
			if err := m.MakerComakerTable[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("makerComakerTable" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMarketingChannelsData(formats strfmt.Registry) error {

	if swag.IsZero(m.MarketingChannelsData) { // not required
		return nil
	}

	for i := 0; i < len(m.MarketingChannelsData); i++ {
		if swag.IsZero(m.MarketingChannelsData[i]) { // not required
			continue
		}

		if m.MarketingChannelsData[i] != nil {
			if err := m.MarketingChannelsData[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("marketingChannelsData" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMarketingOptOut(formats strfmt.Registry) error {

	if swag.IsZero(m.MarketingOptOut) { // not required
		return nil
	}

	if err := validate.MinLength("marketingOptOut", "body", string(*m.MarketingOptOut), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("marketingOptOut", "body", string(*m.MarketingOptOut), 1); err != nil {
		return err
	}

	if err := validate.Pattern("marketingOptOut", "body", string(*m.MarketingOptOut), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMarketingProductsData(formats strfmt.Registry) error {

	if swag.IsZero(m.MarketingProductsData) { // not required
		return nil
	}

	for i := 0; i < len(m.MarketingProductsData); i++ {
		if swag.IsZero(m.MarketingProductsData[i]) { // not required
			continue
		}

		if m.MarketingProductsData[i] != nil {
			if err := m.MarketingProductsData[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("marketingProductsData" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMemoBillCurrency(formats strfmt.Registry) error {

	if swag.IsZero(m.MemoBillCurrency) { // not required
		return nil
	}

	if err := validate.MinLength("memoBillCurrency", "body", string(*m.MemoBillCurrency), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("memoBillCurrency", "body", string(*m.MemoBillCurrency), 3); err != nil {
		return err
	}

	if err := validate.Pattern("memoBillCurrency", "body", string(*m.MemoBillCurrency), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMemorableWord(formats strfmt.Registry) error {

	if swag.IsZero(m.MemorableWord) { // not required
		return nil
	}

	if err := validate.MinLength("memorableWord", "body", string(*m.MemorableWord), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("memorableWord", "body", string(*m.MemorableWord), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMemorableWordReminder(formats strfmt.Registry) error {

	if swag.IsZero(m.MemorableWordReminder) { // not required
		return nil
	}

	if err := validate.MinLength("memorableWordReminder", "body", string(*m.MemorableWordReminder), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("memorableWordReminder", "body", string(*m.MemorableWordReminder), 30); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMini(formats strfmt.Registry) error {

	if swag.IsZero(m.Mini) { // not required
		return nil
	}

	if err := validate.MinLength("mini", "body", string(*m.Mini), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mini", "body", string(*m.Mini), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscScr(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscScr) { // not required
		return nil
	}

	if err := validate.Pattern("miscScr", "body", string(m.MiscScr), `^(-)?[0-9]{1,5}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser1(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser1) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser1", "body", string(*m.MiscUser1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser1", "body", string(*m.MiscUser1), 30); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser10(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser10) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser10", "body", string(*m.MiscUser10), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser10", "body", string(*m.MiscUser10), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser11(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser11) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser11", "body", string(*m.MiscUser11), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser11", "body", string(*m.MiscUser11), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser12(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser12) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser12", "body", string(*m.MiscUser12), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser12", "body", string(*m.MiscUser12), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser2(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser2) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser2", "body", string(*m.MiscUser2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser2", "body", string(*m.MiscUser2), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser3(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser3) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser3", "body", string(*m.MiscUser3), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser3", "body", string(*m.MiscUser3), 11); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser4(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser4) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser4", "body", string(*m.MiscUser4), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser4", "body", string(*m.MiscUser4), 11); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser5(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser5) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser5", "body", string(*m.MiscUser5), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser5", "body", string(*m.MiscUser5), 11); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser6(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser6) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser6", "body", string(*m.MiscUser6), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser6", "body", string(*m.MiscUser6), 11); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser7(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser7) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser7", "body", string(*m.MiscUser7), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser7", "body", string(*m.MiscUser7), 11); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser8(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser8) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser8", "body", string(*m.MiscUser8), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser8", "body", string(*m.MiscUser8), 11); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMiscUser9(formats strfmt.Registry) error {

	if swag.IsZero(m.MiscUser9) { // not required
		return nil
	}

	if err := validate.MinLength("miscUser9", "body", string(*m.MiscUser9), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("miscUser9", "body", string(*m.MiscUser9), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMobDeviceID(formats strfmt.Registry) error {

	if swag.IsZero(m.MobDeviceID) { // not required
		return nil
	}

	if err := validate.MinLength("mobDeviceId", "body", string(*m.MobDeviceID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mobDeviceId", "body", string(*m.MobDeviceID), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMobPiAllowed(formats strfmt.Registry) error {

	if swag.IsZero(m.MobPiAllowed) { // not required
		return nil
	}

	if err := validate.MinLength("mobPiAllowed", "body", string(*m.MobPiAllowed), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mobPiAllowed", "body", string(*m.MobPiAllowed), 1); err != nil {
		return err
	}

	if err := validate.Pattern("mobPiAllowed", "body", string(*m.MobPiAllowed), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMobProvStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.MobProvStatus) { // not required
		return nil
	}

	if err := validate.MinLength("mobProvStatus", "body", string(*m.MobProvStatus), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mobProvStatus", "body", string(*m.MobProvStatus), 1); err != nil {
		return err
	}

	if err := validate.Pattern("mobProvStatus", "body", string(*m.MobProvStatus), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMsCardLogoTable(formats strfmt.Registry) error {

	if swag.IsZero(m.MsCardLogoTable) { // not required
		return nil
	}

	for i := 0; i < len(m.MsCardLogoTable); i++ {
		if swag.IsZero(m.MsCardLogoTable[i]) { // not required
			continue
		}

		if m.MsCardLogoTable[i] != nil {
			if err := m.MsCardLogoTable[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("msCardLogoTable" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateMultiSchemeCardSetID(formats strfmt.Registry) error {

	if swag.IsZero(m.MultiSchemeCardSetID) { // not required
		return nil
	}

	if err := validate.MinLength("multiSchemeCardSetId", "body", string(*m.MultiSchemeCardSetID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("multiSchemeCardSetId", "body", string(*m.MultiSchemeCardSetID), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateNbrCardsRequested(formats strfmt.Registry) error {

	if swag.IsZero(m.NbrCardsRequested) { // not required
		return nil
	}

	if err := validate.MinLength("nbrCardsRequested", "body", string(*m.NbrCardsRequested), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("nbrCardsRequested", "body", string(*m.NbrCardsRequested), 2); err != nil {
		return err
	}

	if err := validate.Pattern("nbrCardsRequested", "body", string(*m.NbrCardsRequested), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateNewAcctCampaign(formats strfmt.Registry) error {

	if swag.IsZero(m.NewAcctCampaign) { // not required
		return nil
	}

	if err := validate.MinLength("newAcctCampaign", "body", string(*m.NewAcctCampaign), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("newAcctCampaign", "body", string(*m.NewAcctCampaign), 8); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOfferCodeOvrd(formats strfmt.Registry) error {

	if swag.IsZero(m.OfferCodeOvrd) { // not required
		return nil
	}

	if err := validate.MinLength("offerCodeOvrd", "body", string(*m.OfferCodeOvrd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("offerCodeOvrd", "body", string(*m.OfferCodeOvrd), 10); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOfficerCode(formats strfmt.Registry) error {

	if swag.IsZero(m.OfficerCode) { // not required
		return nil
	}

	if err := validate.MinLength("officerCode", "body", string(*m.OfficerCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("officerCode", "body", string(*m.OfficerCode), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOfflinePin(formats strfmt.Registry) error {

	if swag.IsZero(m.OfflinePin) { // not required
		return nil
	}

	if err := validate.MinLength("offlinePin", "body", string(*m.OfflinePin), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("offlinePin", "body", string(*m.OfflinePin), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOndemDcBic(formats strfmt.Registry) error {

	if swag.IsZero(m.OndemDcBic) { // not required
		return nil
	}

	if err := validate.MinLength("ondemDcBic", "body", string(*m.OndemDcBic), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ondemDcBic", "body", string(*m.OndemDcBic), 11); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOndemDcIban(formats strfmt.Registry) error {

	if swag.IsZero(m.OndemDcIban) { // not required
		return nil
	}

	if err := validate.MinLength("ondemDcIban", "body", string(*m.OndemDcIban), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ondemDcIban", "body", string(*m.OndemDcIban), 34); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOtaSmsInd(formats strfmt.Registry) error {

	if swag.IsZero(m.OtaSmsInd) { // not required
		return nil
	}

	if err := validate.MinLength("otaSmsInd", "body", string(*m.OtaSmsInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("otaSmsInd", "body", string(*m.OtaSmsInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOtaThres(formats strfmt.Registry) error {

	if swag.IsZero(m.OtaThres) { // not required
		return nil
	}

	if err := validate.MinLength("otaThres", "body", string(*m.OtaThres), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("otaThres", "body", string(*m.OtaThres), 13); err != nil {
		return err
	}

	if err := validate.Pattern("otaThres", "body", string(*m.OtaThres), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOtbSmsInd(formats strfmt.Registry) error {

	if swag.IsZero(m.OtbSmsInd) { // not required
		return nil
	}

	if err := validate.MinLength("otbSmsInd", "body", string(*m.OtbSmsInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("otbSmsInd", "body", string(*m.OtbSmsInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOtbThres(formats strfmt.Registry) error {

	if swag.IsZero(m.OtbThres) { // not required
		return nil
	}

	if err := validate.MinLength("otbThres", "body", string(*m.OtbThres), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("otbThres", "body", string(*m.OtbThres), 11); err != nil {
		return err
	}

	if err := validate.Pattern("otbThres", "body", string(*m.OtbThres), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOtcCashAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.OtcCashAmount) { // not required
		return nil
	}

	if err := validate.Pattern("otcCashAmount", "body", string(m.OtcCashAmount), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOtcCashNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.OtcCashNumber) { // not required
		return nil
	}

	if err := validate.Pattern("otcCashNumber", "body", string(m.OtcCashNumber), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOverLmtAlert(formats strfmt.Registry) error {

	if swag.IsZero(m.OverLmtAlert) { // not required
		return nil
	}

	if err := validate.MinLength("overLmtAlert", "body", string(*m.OverLmtAlert), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("overLmtAlert", "body", string(*m.OverLmtAlert), 1); err != nil {
		return err
	}

	if err := validate.Pattern("overLmtAlert", "body", string(*m.OverLmtAlert), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOwnerCoownerInd(formats strfmt.Registry) error {

	if swag.IsZero(m.OwnerCoownerInd) { // not required
		return nil
	}

	if err := validate.MinLength("ownerCoownerInd", "body", string(*m.OwnerCoownerInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ownerCoownerInd", "body", string(*m.OwnerCoownerInd), 1); err != nil {
		return err
	}

	if err := validate.Pattern("ownerCoownerInd", "body", string(*m.OwnerCoownerInd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOwningBranch(formats strfmt.Registry) error {

	if swag.IsZero(m.OwningBranch) { // not required
		return nil
	}

	if err := validate.MinLength("owningBranch", "body", string(*m.OwningBranch), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("owningBranch", "body", string(*m.OwningBranch), 9); err != nil {
		return err
	}

	if err := validate.Pattern("owningBranch", "body", string(*m.OwningBranch), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateOwningStore(formats strfmt.Registry) error {

	if swag.IsZero(m.OwningStore) { // not required
		return nil
	}

	if err := validate.MinLength("owningStore", "body", string(*m.OwningStore), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("owningStore", "body", string(*m.OwningStore), 9); err != nil {
		return err
	}

	if err := validate.Pattern("owningStore", "body", string(*m.OwningStore), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validatePctLevelOverride(formats strfmt.Registry) error {

	if swag.IsZero(m.PctLevelOverride) { // not required
		return nil
	}

	if err := validate.MinLength("pctLevelOverride", "body", string(*m.PctLevelOverride), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("pctLevelOverride", "body", string(*m.PctLevelOverride), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validatePinOverride(formats strfmt.Registry) error {

	if swag.IsZero(m.PinOverride) { // not required
		return nil
	}

	if err := validate.MinLength("pinOverride", "body", string(*m.PinOverride), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("pinOverride", "body", string(*m.PinOverride), 1); err != nil {
		return err
	}

	if err := validate.Pattern("pinOverride", "body", string(*m.PinOverride), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validatePinSuppression(formats strfmt.Registry) error {

	if swag.IsZero(m.PinSuppression) { // not required
		return nil
	}

	if err := validate.MinLength("pinSuppression", "body", string(*m.PinSuppression), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("pinSuppression", "body", string(*m.PinSuppression), 1); err != nil {
		return err
	}

	if err := validate.Pattern("pinSuppression", "body", string(*m.PinSuppression), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validatePlasticID(formats strfmt.Registry) error {

	if swag.IsZero(m.PlasticID) { // not required
		return nil
	}

	if err := validate.MinLength("plasticId", "body", string(*m.PlasticID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("plasticId", "body", string(*m.PlasticID), 10); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validatePmtDueAlert(formats strfmt.Registry) error {

	if swag.IsZero(m.PmtDueAlert) { // not required
		return nil
	}

	if err := validate.MinLength("pmtDueAlert", "body", string(*m.PmtDueAlert), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("pmtDueAlert", "body", string(*m.PmtDueAlert), 1); err != nil {
		return err
	}

	if err := validate.Pattern("pmtDueAlert", "body", string(*m.PmtDueAlert), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validatePmtDueRemDays(formats strfmt.Registry) error {

	if swag.IsZero(m.PmtDueRemDays) { // not required
		return nil
	}

	if err := validate.MinLength("pmtDueRemDays", "body", string(*m.PmtDueRemDays), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("pmtDueRemDays", "body", string(*m.PmtDueRemDays), 2); err != nil {
		return err
	}

	if err := validate.Pattern("pmtDueRemDays", "body", string(*m.PmtDueRemDays), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validatePricingCtrl(formats strfmt.Registry) error {

	if swag.IsZero(m.PricingCtrl) { // not required
		return nil
	}

	if err := validate.MinLength("pricingCtrl", "body", string(*m.PricingCtrl), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("pricingCtrl", "body", string(*m.PricingCtrl), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validatePrimary(formats strfmt.Registry) error {

	if swag.IsZero(m.Primary) { // not required
		return nil
	}

	if err := validate.MinLength("primary", "body", string(*m.Primary), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("primary", "body", string(*m.Primary), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateProgramID(formats strfmt.Registry) error {

	if swag.IsZero(m.ProgramID) { // not required
		return nil
	}

	if err := validate.MinLength("programId", "body", string(*m.ProgramID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("programId", "body", string(*m.ProgramID), 9); err != nil {
		return err
	}

	if err := validate.Pattern("programId", "body", string(*m.ProgramID), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateQuasiCashAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.QuasiCashAmount) { // not required
		return nil
	}

	if err := validate.Pattern("quasiCashAmount", "body", string(m.QuasiCashAmount), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateQuasiCashAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.QuasiCashAmt) { // not required
		return nil
	}

	if err := validate.Pattern("quasiCashAmt", "body", string(m.QuasiCashAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateQuasiCashNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.QuasiCashNbr) { // not required
		return nil
	}

	if err := validate.Pattern("quasiCashNbr", "body", string(m.QuasiCashNbr), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateQuasiCashNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.QuasiCashNumber) { // not required
		return nil
	}

	if err := validate.Pattern("quasiCashNumber", "body", string(m.QuasiCashNumber), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateReissueBranch(formats strfmt.Registry) error {

	if swag.IsZero(m.ReissueBranch) { // not required
		return nil
	}

	if err := validate.MinLength("reissueBranch", "body", string(*m.ReissueBranch), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("reissueBranch", "body", string(*m.ReissueBranch), 9); err != nil {
		return err
	}

	if err := validate.Pattern("reissueBranch", "body", string(*m.ReissueBranch), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateReissueBranchDelivOption(formats strfmt.Registry) error {

	if swag.IsZero(m.ReissueBranchDelivOption) { // not required
		return nil
	}

	if err := validate.MinLength("reissueBranchDelivOption", "body", string(*m.ReissueBranchDelivOption), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("reissueBranchDelivOption", "body", string(*m.ReissueBranchDelivOption), 3); err != nil {
		return err
	}

	if err := validate.Pattern("reissueBranchDelivOption", "body", string(*m.ReissueBranchDelivOption), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateRelationshipNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.RelationshipNumber) { // not required
		return nil
	}

	if err := validate.MinLength("relationshipNumber", "body", string(*m.RelationshipNumber), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("relationshipNumber", "body", string(*m.RelationshipNumber), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateResidenceID(formats strfmt.Registry) error {

	if swag.IsZero(m.ResidenceID) { // not required
		return nil
	}

	if err := validate.MinLength("residenceId", "body", string(*m.ResidenceID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("residenceId", "body", string(*m.ResidenceID), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateRetailPurchAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.RetailPurchAmount) { // not required
		return nil
	}

	if err := validate.Pattern("retailPurchAmount", "body", string(m.RetailPurchAmount), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateRetailPurchNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.RetailPurchNumber) { // not required
		return nil
	}

	if err := validate.Pattern("retailPurchNumber", "body", string(m.RetailPurchNumber), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateRewdSchemeIden(formats strfmt.Registry) error {

	if swag.IsZero(m.RewdSchemeIden) { // not required
		return nil
	}

	if err := validate.MinLength("rewdSchemeIden", "body", string(*m.RewdSchemeIden), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("rewdSchemeIden", "body", string(*m.RewdSchemeIden), 4); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSalesExec1(formats strfmt.Registry) error {

	if swag.IsZero(m.SalesExec1) { // not required
		return nil
	}

	if err := validate.MinLength("salesExec1", "body", string(*m.SalesExec1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("salesExec1", "body", string(*m.SalesExec1), 6); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSalesExec2(formats strfmt.Registry) error {

	if swag.IsZero(m.SalesExec2) { // not required
		return nil
	}

	if err := validate.MinLength("salesExec2", "body", string(*m.SalesExec2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("salesExec2", "body", string(*m.SalesExec2), 6); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSalesExec3(formats strfmt.Registry) error {

	if swag.IsZero(m.SalesExec3) { // not required
		return nil
	}

	if err := validate.MinLength("salesExec3", "body", string(*m.SalesExec3), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("salesExec3", "body", string(*m.SalesExec3), 6); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSdpProcessType(formats strfmt.Registry) error {

	if err := validate.Required("sdpProcessType", "body", m.SdpProcessType); err != nil {
		return err
	}

	if err := validate.MinLength("sdpProcessType", "body", string(*m.SdpProcessType), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("sdpProcessType", "body", string(*m.SdpProcessType), 1); err != nil {
		return err
	}

	if err := validate.Pattern("sdpProcessType", "body", string(*m.SdpProcessType), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSecurecodeAct(formats strfmt.Registry) error {

	if swag.IsZero(m.SecurecodeAct) { // not required
		return nil
	}

	if err := validate.MinLength("securecodeAct", "body", string(*m.SecurecodeAct), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("securecodeAct", "body", string(*m.SecurecodeAct), 1); err != nil {
		return err
	}

	if err := validate.Pattern("securecodeAct", "body", string(*m.SecurecodeAct), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateShortName(formats strfmt.Registry) error {

	if swag.IsZero(m.ShortName) { // not required
		return nil
	}

	if err := validate.MinLength("shortName", "body", string(*m.ShortName), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("shortName", "body", string(*m.ShortName), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSlfSelPinBlock(formats strfmt.Registry) error {

	if swag.IsZero(m.SlfSelPinBlock) { // not required
		return nil
	}

	if err := validate.MinLength("slfSelPinBlock", "body", string(*m.SlfSelPinBlock), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("slfSelPinBlock", "body", string(*m.SlfSelPinBlock), 16); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSmsAlerts(formats strfmt.Registry) error {

	if swag.IsZero(m.SmsAlerts) { // not required
		return nil
	}

	if err := validate.MinLength("smsAlerts", "body", string(*m.SmsAlerts), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("smsAlerts", "body", string(*m.SmsAlerts), 1); err != nil {
		return err
	}

	if err := validate.Pattern("smsAlerts", "body", string(*m.SmsAlerts), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSmsGenBankingInd(formats strfmt.Registry) error {

	if swag.IsZero(m.SmsGenBankingInd) { // not required
		return nil
	}

	if err := validate.MinLength("smsGenBankingInd", "body", string(*m.SmsGenBankingInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("smsGenBankingInd", "body", string(*m.SmsGenBankingInd), 1); err != nil {
		return err
	}

	if err := validate.Pattern("smsGenBankingInd", "body", string(*m.SmsGenBankingInd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSnglCshLmt(formats strfmt.Registry) error {

	if swag.IsZero(m.SnglCshLmt) { // not required
		return nil
	}

	if err := validate.Pattern("snglCshLmt", "body", string(m.SnglCshLmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSource(formats strfmt.Registry) error {

	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if err := validate.MinLength("source", "body", string(*m.Source), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("source", "body", string(*m.Source), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSourceChannel(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceChannel) { // not required
		return nil
	}

	if err := validate.MinLength("sourceChannel", "body", string(*m.SourceChannel), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("sourceChannel", "body", string(*m.SourceChannel), 1); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSpndLmtAlert(formats strfmt.Registry) error {

	if swag.IsZero(m.SpndLmtAlert) { // not required
		return nil
	}

	if err := validate.MinLength("spndLmtAlert", "body", string(*m.SpndLmtAlert), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("spndLmtAlert", "body", string(*m.SpndLmtAlert), 1); err != nil {
		return err
	}

	if err := validate.Pattern("spndLmtAlert", "body", string(*m.SpndLmtAlert), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSpndLmtAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.SpndLmtAmt) { // not required
		return nil
	}

	if err := validate.MinLength("spndLmtAmt", "body", string(*m.SpndLmtAmt), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("spndLmtAmt", "body", string(*m.SpndLmtAmt), 9); err != nil {
		return err
	}

	if err := validate.Pattern("spndLmtAmt", "body", string(*m.SpndLmtAmt), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateStPr(formats strfmt.Registry) error {

	if swag.IsZero(m.StPr) { // not required
		return nil
	}

	if err := validate.MinLength("stPr", "body", string(*m.StPr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("stPr", "body", string(*m.StPr), 3); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSuppFeeInd(formats strfmt.Registry) error {

	if swag.IsZero(m.SuppFeeInd) { // not required
		return nil
	}

	if err := validate.MinLength("suppFeeInd", "body", string(*m.SuppFeeInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("suppFeeInd", "body", string(*m.SuppFeeInd), 1); err != nil {
		return err
	}

	if err := validate.Pattern("suppFeeInd", "body", string(*m.SuppFeeInd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSvcFeeExpDt(formats strfmt.Registry) error {

	if swag.IsZero(m.SvcFeeExpDt) { // not required
		return nil
	}

	if err := validate.MinLength("svcFeeExpDt", "body", string(*m.SvcFeeExpDt), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("svcFeeExpDt", "body", string(*m.SvcFeeExpDt), 7); err != nil {
		return err
	}

	if err := validate.Pattern("svcFeeExpDt", "body", string(*m.SvcFeeExpDt), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSvcFeeStrtDt(formats strfmt.Registry) error {

	if swag.IsZero(m.SvcFeeStrtDt) { // not required
		return nil
	}

	if err := validate.MinLength("svcFeeStrtDt", "body", string(*m.SvcFeeStrtDt), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("svcFeeStrtDt", "body", string(*m.SvcFeeStrtDt), 7); err != nil {
		return err
	}

	if err := validate.Pattern("svcFeeStrtDt", "body", string(*m.SvcFeeStrtDt), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateSvcFeeTable(formats strfmt.Registry) error {

	if swag.IsZero(m.SvcFeeTable) { // not required
		return nil
	}

	if err := validate.MinLength("svcFeeTable", "body", string(*m.SvcFeeTable), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("svcFeeTable", "body", string(*m.SvcFeeTable), 3); err != nil {
		return err
	}

	if err := validate.Pattern("svcFeeTable", "body", string(*m.SvcFeeTable), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateTempCreditLine(formats strfmt.Registry) error {

	if swag.IsZero(m.TempCreditLine) { // not required
		return nil
	}

	if err := validate.Pattern("tempCreditLine", "body", string(m.TempCreditLine), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateTermCond(formats strfmt.Registry) error {

	if swag.IsZero(m.TermCond) { // not required
		return nil
	}

	if err := validate.MinLength("termCond", "body", string(*m.TermCond), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("termCond", "body", string(*m.TermCond), 4); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateTotalCashAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalCashAmt) { // not required
		return nil
	}

	if err := validate.Pattern("totalCashAmt", "body", string(m.TotalCashAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateTotalCashNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalCashNumber) { // not required
		return nil
	}

	if err := validate.Pattern("totalCashNumber", "body", string(m.TotalCashNumber), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateTotalTxnAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalTxnAmount) { // not required
		return nil
	}

	if err := validate.Pattern("totalTxnAmount", "body", string(m.TotalTxnAmount), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateTotalTxnNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.TotalTxnNumber) { // not required
		return nil
	}

	if err := validate.Pattern("totalTxnNumber", "body", string(m.TotalTxnNumber), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateTransactionLimitQuasi(formats strfmt.Registry) error {

	if swag.IsZero(m.TransactionLimitQuasi) { // not required
		return nil
	}

	if err := validate.Pattern("transactionLimitQuasi", "body", string(m.TransactionLimitQuasi), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUniqueID(formats strfmt.Registry) error {

	if swag.IsZero(m.UniqueID) { // not required
		return nil
	}

	if err := validate.MinLength("uniqueId", "body", string(*m.UniqueID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("uniqueId", "body", string(*m.UniqueID), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUser10(formats strfmt.Registry) error {

	if swag.IsZero(m.User10) { // not required
		return nil
	}

	if err := validate.MinLength("user10", "body", string(*m.User10), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user10", "body", string(*m.User10), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUser9(formats strfmt.Registry) error {

	if swag.IsZero(m.User9) { // not required
		return nil
	}

	if err := validate.MinLength("user9", "body", string(*m.User9), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user9", "body", string(*m.User9), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAcctNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAcctNbr) { // not required
		return nil
	}

	if err := validate.MinLength("userAcctNbr", "body", string(*m.UserAcctNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userAcctNbr", "body", string(*m.UserAcctNbr), 19); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt1(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt1) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt1", "body", string(m.UserAmt1), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt10(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt10) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt10", "body", string(m.UserAmt10), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt11(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt11) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt11", "body", string(m.UserAmt11), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt12(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt12) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt12", "body", string(m.UserAmt12), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt13(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt13) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt13", "body", string(m.UserAmt13), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt14(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt14) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt14", "body", string(m.UserAmt14), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt2(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt2) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt2", "body", string(m.UserAmt2), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt3(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt3) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt3", "body", string(m.UserAmt3), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt4(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt4) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt4", "body", string(m.UserAmt4), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt5(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt5) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt5", "body", string(m.UserAmt5), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt6(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt6) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt6", "body", string(m.UserAmt6), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt7(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt7) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt7", "body", string(m.UserAmt7), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt8(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt8) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt8", "body", string(m.UserAmt8), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAmt9(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAmt9) { // not required
		return nil
	}

	if err := validate.Pattern("userAmt9", "body", string(m.UserAmt9), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAppl1(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAppl1) { // not required
		return nil
	}

	if err := validate.MinLength("userAppl1", "body", string(*m.UserAppl1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userAppl1", "body", string(*m.UserAppl1), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserAppl2(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAppl2) { // not required
		return nil
	}

	if err := validate.MinLength("userAppl2", "body", string(*m.UserAppl2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userAppl2", "body", string(*m.UserAppl2), 20); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode1(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode1) { // not required
		return nil
	}

	if err := validate.MinLength("userCode1", "body", string(*m.UserCode1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode1", "body", string(*m.UserCode1), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode10(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode10) { // not required
		return nil
	}

	if err := validate.MinLength("userCode10", "body", string(*m.UserCode10), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode10", "body", string(*m.UserCode10), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode11(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode11) { // not required
		return nil
	}

	if err := validate.MinLength("userCode11", "body", string(*m.UserCode11), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode11", "body", string(*m.UserCode11), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode12(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode12) { // not required
		return nil
	}

	if err := validate.MinLength("userCode12", "body", string(*m.UserCode12), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode12", "body", string(*m.UserCode12), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode13(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode13) { // not required
		return nil
	}

	if err := validate.MinLength("userCode13", "body", string(*m.UserCode13), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode13", "body", string(*m.UserCode13), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode14(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode14) { // not required
		return nil
	}

	if err := validate.MinLength("userCode14", "body", string(*m.UserCode14), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode14", "body", string(*m.UserCode14), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode2(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode2) { // not required
		return nil
	}

	if err := validate.MinLength("userCode2", "body", string(*m.UserCode2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode2", "body", string(*m.UserCode2), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode3(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode3) { // not required
		return nil
	}

	if err := validate.MinLength("userCode3", "body", string(*m.UserCode3), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode3", "body", string(*m.UserCode3), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode4(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode4) { // not required
		return nil
	}

	if err := validate.MinLength("userCode4", "body", string(*m.UserCode4), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode4", "body", string(*m.UserCode4), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode5(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode5) { // not required
		return nil
	}

	if err := validate.MinLength("userCode5", "body", string(*m.UserCode5), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode5", "body", string(*m.UserCode5), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode6(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode6) { // not required
		return nil
	}

	if err := validate.MinLength("userCode6", "body", string(*m.UserCode6), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode6", "body", string(*m.UserCode6), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode7(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode7) { // not required
		return nil
	}

	if err := validate.MinLength("userCode7", "body", string(*m.UserCode7), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode7", "body", string(*m.UserCode7), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode8(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode8) { // not required
		return nil
	}

	if err := validate.MinLength("userCode8", "body", string(*m.UserCode8), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode8", "body", string(*m.UserCode8), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateUserCode9(formats strfmt.Registry) error {

	if swag.IsZero(m.UserCode9) { // not required
		return nil
	}

	if err := validate.MinLength("userCode9", "body", string(*m.UserCode9), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("userCode9", "body", string(*m.UserCode9), 2); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateVipStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.VipStatus) { // not required
		return nil
	}

	if err := validate.MinLength("vipStatus", "body", string(*m.VipStatus), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("vipStatus", "body", string(*m.VipStatus), 1); err != nil {
		return err
	}

	if err := validate.Pattern("vipStatus", "body", string(*m.VipStatus), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateWaiveSuppMemFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.WaiveSuppMemFlag) { // not required
		return nil
	}

	if err := validate.MinLength("waiveSuppMemFlag", "body", string(*m.WaiveSuppMemFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("waiveSuppMemFlag", "body", string(*m.WaiveSuppMemFlag), 1); err != nil {
		return err
	}

	if err := validate.Pattern("waiveSuppMemFlag", "body", string(*m.WaiveSuppMemFlag), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *CustomerAccountEmbosserAddRequest) validateWmPercent(formats strfmt.Registry) error {

	if swag.IsZero(m.WmPercent) { // not required
		return nil
	}

	if err := validate.Pattern("wmPercent", "body", string(m.WmPercent), `^(-)?[0-9]{1,7}$`); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CustomerAccountEmbosserAddRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CustomerAccountEmbosserAddRequest) UnmarshalBinary(b []byte) error {
	var res CustomerAccountEmbosserAddRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
