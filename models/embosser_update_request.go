// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// EmbosserUpdateRequest embosser update request
//
// swagger:model EmbosserUpdateRequest
type EmbosserUpdateRequest struct {

	//  Max length = 1, ADDL FREQ
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AddlFreq *string `json:"addlFreq,omitempty"`

	//  Max length = 17, ADDL TOTAL TXN AMT
	// Pattern: ^(-)?[0-9]{1,17}$
	AddlTotalTxnAmt string `json:"addlTotalTxnAmt,omitempty"`

	//  Max length = 9, ADDL TOTAL TXN NBR
	// Pattern: ^(-)?[0-9]{1,9}$
	AddlTotalTxnNbr string `json:"addlTotalTxnNbr,omitempty"`

	//  Max length = 40, Address Line 1: First line of the address to which the card and PIN mailer is sent.
	// Max Length: 40
	// Min Length: 0
	AddrLine1 *string `json:"addrLine1,omitempty"`

	//  Max length = 40, Address Line 2: Second line of the address to which the card and PIN mailer is sent.
	// Max Length: 40
	// Min Length: 0
	AddrLine2 *string `json:"addrLine2,omitempty"`

	//  Max length = 1, All Restrict: Flag to indicate whether all types of monetary authorizations are restricted on the embosser or not.  Valid value are: 0 - Embosser has no all authorization restrictions (default) 1 - Embosser has all authorizations restricted
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AlRestriction *string `json:"alRestriction,omitempty"`

	//  Max length = 17, ATM DAILY AMT
	// Pattern: ^(-)?[0-9]{1,17}$
	AtmDailyAmt string `json:"atmDailyAmt,omitempty"`

	//  Max length = 1, ATM Restriction Flag: Flag to indicate whether ATM transactions have been restricted on the embosser or not. Valid values are:    0 - Embosser has no ATM restrictions (Default) 1 - Embosser has ATM transactions restricted  2 - Embosser has domestic ATM transactions restricted 3 - Embosser has international ATM transactions restricted
	// Max Length: 1
	// Min Length: 0
	AtmRestFlag *string `json:"atmRestFlag,omitempty"`

	//  Max length = 17, AUTH ATM CASH AMT
	// Pattern: ^(-)?[0-9]{1,17}$
	AuthAtmCashAmt string `json:"authAtmCashAmt,omitempty"`

	//  Max length = 9, AUTH ATM CASH NBR
	// Pattern: ^(-)?[0-9]{1,9}$
	AuthAtmCashNbr string `json:"authAtmCashNbr,omitempty"`

	//  Max length = 17, AUTH ATM CASH SNGL TXN
	// Pattern: ^(-)?[0-9]{1,17}$
	AuthAtmCashSnglTxn string `json:"authAtmCashSnglTxn,omitempty"`

	//  Max length = 1, AUTH ATM OTC RTL FREQ
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	AuthAtmOtcRtlFreq *string `json:"authAtmOtcRtlFreq,omitempty"`

	//  Max length = 17, AUTH OTC CASH AMT
	// Pattern: ^(-)?[0-9]{1,17}$
	AuthOtcCashAmt string `json:"authOtcCashAmt,omitempty"`

	//  Max length = 9, AUTH OTC CASH NBR
	// Pattern: ^(-)?[0-9]{1,9}$
	AuthOtcCashNbr string `json:"authOtcCashNbr,omitempty"`

	//  Max length = 17, AUTH OTC CASH SNGL
	// Pattern: ^(-)?[0-9]{1,17}$
	AuthOtcCashSngl string `json:"authOtcCashSngl,omitempty"`

	//  Max length = 17, AUTH RTL AMT
	// Pattern: ^(-)?[0-9]{1,17}$
	AuthRtlAmt string `json:"authRtlAmt,omitempty"`

	//  Max length = 9, AUTH RTL NBR
	// Pattern: ^(-)?[0-9]{1,9}$
	AuthRtlNbr string `json:"authRtlNbr,omitempty"`

	//  Max length = 17, AUTH RTL SNGL TXN
	// Pattern: ^(-)?[0-9]{1,17}$
	AuthRtlSnglTxn string `json:"authRtlSnglTxn,omitempty"`

	//  Max length = 17, AUTH TOTAL TXN AMT
	// Pattern: ^(-)?[0-9]{1,17}$
	AuthTotalTxnAmt string `json:"authTotalTxnAmt,omitempty"`

	//  Max length = 9, AUTH TOTAL TXN NBR
	// Pattern: ^(-)?[0-9]{1,9}$
	AuthTotalTxnNbr string `json:"authTotalTxnNbr,omitempty"`

	//  Max length = 19, Card Number: Unique Card number embossed on the plastic card. 1. Must be numeric and greater than 0 2. Card number must be on file 3. Card number must be valid for Org provided
	// Required: true
	// Max Length: 19
	// Min Length: 0
	CardNbr *string `json:"cardNbr"`

	//  Max length = 4, Card Sequence Number: Identification number assigned to Embosser record to distinguish between multiple cards issued with the same card.1. Must be numeric and greater than 0 if provided2. Must be between 0 and 99 if smart card3. If not provided, and not a smart card, default to value of 0001
	// Max Length: 4
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CardSeq *string `json:"cardSeq,omitempty"`

	//  Max length = 1, Cardholder Flag: Flag that indicates whether the card is issued as a primary or secondary card.  Values are:  '0' - Primary Cardholder  '1' - Additional Cardholder
	// Max Length: 1
	// Min Length: 0
	CardholderFlag *string `json:"cardholderFlag,omitempty"`

	//  Max length = 30, City for the mailing address to be used for card and PIN mailer.
	// Max Length: 30
	// Min Length: 0
	City *string `json:"city,omitempty"`

	// common
	Common *Header `json:"common,omitempty"`

	//  Max length = 3, Card Limit Profile: Code that identifies the BASE24 card limit profile for this Embosser record.
	// Max Length: 3
	// Min Length: 0
	CrdLmtProf *string `json:"crdLmtProf,omitempty"`

	//  Max length = 19, Customer number: Number that identifies the Customer Name/Address record to which this account is assigned.A valid customer name and address must be on file for this account.
	// Max Length: 19
	// Min Length: 0
	CustomerNbr *string `json:"customerNbr,omitempty"`

	//  Max length = 1, Disability Indicator: used to identify customers (at account level) that have a requirement for correspondence to be sent in a particular format.  Values are:                          Blank = Not used (Default) A = Audio B = Braille C = CD-ROM H = Hard of hearing/Minicom L = Large print P = Plain text E = Elderly (old age) M = Mental difficulties O = Other.
	// Max Length: 1
	// Min Length: 0
	DisabltyInd *string `json:"disabltyInd,omitempty"`

	//  Max length = 1, Customer INIT indicator. Valid values are: Disability Init  - 'Y' Disability not  Init - 'N'
	// Max Length: 1
	// Min Length: 0
	DisabltyInit *string `json:"disabltyInit,omitempty"`

	//  Max length = 17, ECOM AMT
	// Pattern: ^(-)?[0-9]{1,17}$
	EcomAmt string `json:"ecomAmt,omitempty"`

	//  Max length = 17, ECOM AMT ACCUM
	// Pattern: ^(-)?[0-9]{1,17}$
	EcomAmtAccum string `json:"ecomAmtAccum,omitempty"`

	//  Max length = 9, ECOM NBR
	// Pattern: ^(-)?[0-9]{1,9}$
	EcomNbr string `json:"ecomNbr,omitempty"`

	//  Max length = 9, ECOM NBR ACCUM
	// Pattern: ^(-)?[0-9]{1,9}$
	EcomNbrAccum string `json:"ecomNbrAccum,omitempty"`

	//  Max length = 1, E-Commerce Restriction Indicator: Flag that indicates whether e-commerce transactions are restricted for this card or not.  Valid values are:  0 - No e-commerce restrictions on the card (Default) 1 - All e-commerce transactions are restricted on the card 2 - Domestic e-commerce transactions are restricted on the card 3 - International e-commerce transactions are restricted on the card
	// Max Length: 1
	// Min Length: 0
	EcommRestInd *string `json:"ecommRestInd,omitempty"`

	//  Max length = 1, Pin Communication Preference: Field that indicates the PIN delivery option used for the embosser.  If data is entered, valid values are:  * ZERO - DELIVER BY PIN MAILER (DEFAULT). * 1 - DELIVER PIN BY SMS.  * 2 - Deliver PIN by PIN Now Web.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EmbPinCommPref *string `json:"embPinCommPref,omitempty"`

	//  Max length = 1, Pin Communication Preference Override: Field that enables you to set a temporary override for the PIN delivery option that was set in the AMED-PIN-COMM-PREF field, for this individual ACTION request only.  Valid values are: * 0 - Override feature is inactive (Default) * 1 - Deliver the PIN by SMS * 2 - Deliver the PIN by mailer * 3 - Deliver the PIN by SMS in batch mode (system-generated only).   * 4 - Deliver the PIN by PIN Now Web.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EmbPinCommPrefOvrd *string `json:"embPinCommPrefOvrd,omitempty"`

	//  Max length = 20, Memorable word: Memorable word used for SMS PIN Data.   Values are: - A to Z - 0-9 - Space - Underscore - Full stop Mandatory if customer chooses PIN by SMS mode or logo level preference is SMS.
	// Max Length: 20
	// Min Length: 0
	EmbPinMemWord *string `json:"embPinMemWord,omitempty"`

	//  Max length = 20, Pin Mobile Number: Mobile Phone number used for receiving PIN data.   1. Should not have + character 2. Must be left justified and space filled. Field should contain only numeric data 3. Should not be any spaces between the digits 4. Should not contain leading zeroes 5. Mandatory if customer chooses PIN by SMS mode or logo level preference is SMS
	// Max Length: 20
	// Min Length: 0
	EmbPinMobileNbr *string `json:"embPinMobileNbr,omitempty"`

	//  Max length = 5, EMBLM ID
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EmblmID *string `json:"emblmId,omitempty"`

	//  Max length = 26, Embossed Name 1: Name to be embossed on the first embossing line of the card.
	// Max Length: 26
	// Min Length: 0
	EmbossedName1 *string `json:"embossedName1,omitempty"`

	//  Max length = 26, Embossed Name 2: Name to be embossed on the second embossing line of the card.
	// Max Length: 26
	// Min Length: 0
	EmbossedName2 *string `json:"embossedName2,omitempty"`

	//  Max length = 40, Embosser Name 1: Name field 1 of the Cardholder, used for mailing card and PIN mailers.
	// Max Length: 40
	// Min Length: 0
	EmbrName1 *string `json:"embrName1,omitempty"`

	//  Max length = 40, Embosser Name 2: Name field 2 of the cardholder, used for mailing card and PIN mailers.
	// Max Length: 40
	// Min Length: 0
	EmbrName2 *string `json:"embrName2,omitempty"`

	//  Max length = 1, Foreign use indicator: Value indicates whether the incoming action is applied to the local or foreign account. The values are: 0 = Local account (default) 1 = Foreign account SPACE = defaults to 0
	// Required: true
	// Max Length: 1
	// Min Length: 0
	ForeignUse *string `json:"foreignUse"`

	//  Max length = 1, INV PIN TRIES
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	InvPinTries *string `json:"invPinTries,omitempty"`

	//  Max length = 3, Language Code: User-defined code to indicate the language spoken by the cardholder.
	// Max Length: 3
	// Min Length: 0
	LangCode *string `json:"langCode,omitempty"`

	//  Max length = 20, Mobile Device ID: Identification of a mobile device associated with a mobile payment instrument (PI) embosser. No validation is performed on this field,
	// Max Length: 20
	// Min Length: 0
	MobDeviceID *string `json:"mobDeviceId,omitempty"`

	//  Max length = 1, Mobile Provision Status: Code that indicates whether the embosser is for a mobile payment instrument (PI) and the current provisioning status for the PI. Valid values are:  * 0 - NOT APPLICABLE; NOT A MOBILE PI. (DEFAULT) * 1 - MOBILE PI IS READY TO BE PROVISIONED * 2 - MOBILE PI PROVISIONING IS COMPLETE * 3 - PREVIOUS PROVISIONING OF THE MOBILE PI WAS UNSUCCESSFUL * 4 - Previously provisioned mobile PI is removed and cannot be re provisioned; the embosser is inactive.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	MobProvisionStatus *string `json:"mobProvisionStatus,omitempty"`

	//  Max length = 1, MOTO Restriction Flag: Flag to indicate whether MOTO transactions have been restricted on the embosser or not. Valid values are:   0 - Embosser has no MOTO restrictions (Default) 1 - Embosser has MOTO transactions restricted  2 - Embosser has domestic MOTO transactions restricted 3 - Embosser has international MOTO transactions restricted
	// Max Length: 1
	// Min Length: 0
	MotoRestFlag *string `json:"motoRestFlag,omitempty"`

	//  Max length = 1, Overseas Restriction: Flag to indicate whether all types of monetary overseas POS and ATM authorizations are restricted on the embossers or not. Valid values are: 0 - Embosser has no overseas POS and ATM authorization restrictions (Default) 1 - Embosser has overseas POS and ATM authorizations restricted
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	OvrsRestriction *string `json:"ovrsRestriction,omitempty"`

	//  Max length = 10, PLASTIC ID
	// Max Length: 10
	// Min Length: 0
	PlasticID *string `json:"plasticId,omitempty"`

	//  Max length = 1, POS Restriction Flag: Flag to indicate whether POS transactions have been restricted on the embosser or not. Valid values are:   0 - Embosser has no POS restrictions (Default) 1 - Embosser has POS transactions restricted  2 - Embosser has domestic POS transactions restricted 3 - Embosser has international POS transactions restricted
	// Max Length: 1
	// Min Length: 0
	PosRestFlag *string `json:"posRestFlag,omitempty"`

	//  Max length = 1, POST CODE RESTRICTION:  INDICATES WHETHER A SMART CARD CONTACTLESS ISSUANCE IS RESTRICTED FOR THE EMBOSSER BASED ON THE CUSTOMER'S POSTAL CODE.   Valid values are:   No Post code restriction -> 0 Post code restriction yes, Issue smart card -> 1 Post code restriction no, Issue smart contactless -> 2 Bypass post code restriction check, Issue smart contactless -> 3 Bypass post code restriction  check, Issue smart card -> 4
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	PostCdRestr *string `json:"postCdRestr,omitempty"`

	//  Max length = 8, Program ID: Identification number of the smart card program. This value must identify a valid Chip Card Program Definition record for this organization. Following logic is in place: 1. If Program ID > zero, value is validated whether Smart Card Program Definition record is on file. 2. If CARD TECH = 0 (magnetic strip), PROGRAM ID cannot be greater than zero. 3. If Program not > zero, DEFAULT PROGRAM ID field on the logo record (ARML38) is used
	// Max Length: 8
	// Min Length: 0
	// Pattern: ^[0-9]*$
	ProgramID *string `json:"programId,omitempty"`

	//  Max length = 10, Postal code or zip code of the mailing address for card and PIN mailer.
	// Max Length: 10
	// Min Length: 0
	PstlCd *string `json:"pstlCd,omitempty"`

	//  Max length = 17, QUASI CASH AMT
	// Pattern: ^(-)?[0-9]{1,17}$
	QuasiCashAmt string `json:"quasiCashAmt,omitempty"`

	//  Max length = 17, QUASI CASH LIMIT
	// Pattern: ^(-)?[0-9]{1,17}$
	QuasiCashLimit string `json:"quasiCashLimit,omitempty"`

	//  Max length = 9, QUASI CASH NBR
	// Pattern: ^(-)?[0-9]{1,9}$
	QuasiCashNbr string `json:"quasiCashNbr,omitempty"`

	// Format: YYYYMMDD. Restriction End Date: Date from which the usage restriction period expires.
	RestEndDate string `json:"restEndDate,omitempty"`

	// Format: YYYYMMDD. Restriction Start Date: Date from which the usage restriction period starts.
	RestStDate string `json:"restStDate,omitempty"`

	//  Max length = 2, RQTD CARD TYPE
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	RqtdCardType *string `json:"rqtdCardType,omitempty"`

	//  Max length = 3, State or province of the mailing address for card and PIN mailer
	// Max Length: 3
	// Min Length: 0
	StProvince *string `json:"stProvince,omitempty"`

	//  Max length = 17, TXN LIMIT ECOM
	// Pattern: ^(-)?[0-9]{1,17}$
	TxnLimitEcom string `json:"txnLimitEcom,omitempty"`

	//  Max length = 2, TYPE CARD MAILER
	// Max Length: 2
	// Min Length: 0
	TypeCardMailer *string `json:"typeCardMailer,omitempty"`

	//  Max length = 2, TYPE OF CARD
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	TypeOfCard *string `json:"typeOfCard,omitempty"`

	//  Max length = 20, User-defined code or description for this Embosser record. Used for Relationship of Primary and Supplemental Cardholders.
	// Max Length: 20
	// Min Length: 0
	User1 *string `json:"user1,omitempty"`

	//  Max length = 20, User-defined field.
	// Max Length: 20
	// Min Length: 0
	User10 *string `json:"user10,omitempty"`

	//  Max length = 20, User-defined code or description for this Embosser record. Used for Relationship of Primary and Supplemental Cardholders.
	// Max Length: 20
	// Min Length: 0
	User2 *string `json:"user2,omitempty"`

	//  Max length = 19, User-defined code or description for this Embosser record. Used for Relationship of Primary and Supplemental Cardholders.
	// Max Length: 19
	// Min Length: 0
	User3 *string `json:"user3,omitempty"`

	//  Max length = 4, User-defined code or description for this Embosser record. Used for Relationship of Primary and Supplemental Cardholders.
	// Max Length: 4
	// Min Length: 0
	// Pattern: ^[0-9]*$
	User4 *string `json:"user4,omitempty"`

	//  Max length = 1, User-defined code or description for this Embosser record. Used for Relationship of Primary and Supplemental Cardholders.
	// Max Length: 1
	// Min Length: 0
	User5 *string `json:"user5,omitempty"`

	//  Max length = 1, User-defined code or description for this Embosser record. Used for Relationship of Primary and Supplemental Cardholders.
	// Max Length: 1
	// Min Length: 0
	User6 *string `json:"user6,omitempty"`

	//  Max length = 1, User-defined code or description for this Embosser record. Used for Relationship of Primary and Supplemental Cardholders.
	// Max Length: 1
	// Min Length: 0
	User7 *string `json:"user7,omitempty"`

	//  Max length = 1, User-defined code or description for this Embosser record. Used for Relationship of Primary and Supplemental Cardholders.
	// Max Length: 1
	// Min Length: 0
	User8 *string `json:"user8,omitempty"`

	//  Max length = 19, User-defined field.
	// Max Length: 19
	// Min Length: 0
	User9 *string `json:"user9,omitempty"`

	// Format: YYYYMMDD. User-defined date for this Embosser record.  Must be numeric and a valid date. Can be zeros. Contains user specified date.
	UserDate1 string `json:"userDate1,omitempty"`

	// Format: YYYYMMDD. User-defined date for this Embosser record.  Must be numeric and a valid date. Can be zeros. Contains user specified date.
	UserDate2 string `json:"userDate2,omitempty"`

	//  Max length = 17, USR AMT LIM
	// Pattern: ^(-)?[0-9]{1,17}$
	UsrAmtLim string `json:"usrAmtLim,omitempty"`

	// Format: YYYYDDD. USR EXP DATE
	// Pattern: ^(-)?[0-9]{1,7}$
	UsrExpDate string `json:"usrExpDate,omitempty"`
}

// Validate validates this embosser update request
func (m *EmbosserUpdateRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddlFreq(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddlTotalTxnAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddlTotalTxnNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddrLine1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddrLine2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlRestriction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAtmDailyAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAtmRestFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthAtmCashAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthAtmCashNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthAtmCashSnglTxn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthAtmOtcRtlFreq(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthOtcCashAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthOtcCashNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthOtcCashSngl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthRtlAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthRtlNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthRtlSnglTxn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthTotalTxnAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthTotalTxnNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardSeq(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardholderFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCrdLmtProf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisabltyInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisabltyInit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEcomAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEcomAmtAccum(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEcomNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEcomNbrAccum(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEcommRestInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbPinCommPref(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbPinCommPrefOvrd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbPinMemWord(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbPinMobileNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmblmID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbossedName1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbossedName2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbrName1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmbrName2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForeignUse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvPinTries(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLangCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobDeviceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMobProvisionStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMotoRestFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOvrsRestriction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlasticID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosRestFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostCdRestr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProgramID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePstlCd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuasiCashAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuasiCashLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuasiCashNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRqtdCardType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStProvince(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnLimitEcom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypeCardMailer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTypeOfCard(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser10(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser5(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser7(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser8(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser9(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsrAmtLim(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsrExpDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EmbosserUpdateRequest) validateAddlFreq(formats strfmt.Registry) error {

	if swag.IsZero(m.AddlFreq) { // not required
		return nil
	}

	if err := validate.MinLength("addlFreq", "body", string(*m.AddlFreq), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("addlFreq", "body", string(*m.AddlFreq), 1); err != nil {
		return err
	}

	if err := validate.Pattern("addlFreq", "body", string(*m.AddlFreq), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAddlTotalTxnAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.AddlTotalTxnAmt) { // not required
		return nil
	}

	if err := validate.Pattern("addlTotalTxnAmt", "body", string(m.AddlTotalTxnAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAddlTotalTxnNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.AddlTotalTxnNbr) { // not required
		return nil
	}

	if err := validate.Pattern("addlTotalTxnNbr", "body", string(m.AddlTotalTxnNbr), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAddrLine1(formats strfmt.Registry) error {

	if swag.IsZero(m.AddrLine1) { // not required
		return nil
	}

	if err := validate.MinLength("addrLine1", "body", string(*m.AddrLine1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("addrLine1", "body", string(*m.AddrLine1), 40); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAddrLine2(formats strfmt.Registry) error {

	if swag.IsZero(m.AddrLine2) { // not required
		return nil
	}

	if err := validate.MinLength("addrLine2", "body", string(*m.AddrLine2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("addrLine2", "body", string(*m.AddrLine2), 40); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAlRestriction(formats strfmt.Registry) error {

	if swag.IsZero(m.AlRestriction) { // not required
		return nil
	}

	if err := validate.MinLength("alRestriction", "body", string(*m.AlRestriction), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("alRestriction", "body", string(*m.AlRestriction), 1); err != nil {
		return err
	}

	if err := validate.Pattern("alRestriction", "body", string(*m.AlRestriction), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAtmDailyAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.AtmDailyAmt) { // not required
		return nil
	}

	if err := validate.Pattern("atmDailyAmt", "body", string(m.AtmDailyAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAtmRestFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.AtmRestFlag) { // not required
		return nil
	}

	if err := validate.MinLength("atmRestFlag", "body", string(*m.AtmRestFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("atmRestFlag", "body", string(*m.AtmRestFlag), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthAtmCashAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthAtmCashAmt) { // not required
		return nil
	}

	if err := validate.Pattern("authAtmCashAmt", "body", string(m.AuthAtmCashAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthAtmCashNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthAtmCashNbr) { // not required
		return nil
	}

	if err := validate.Pattern("authAtmCashNbr", "body", string(m.AuthAtmCashNbr), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthAtmCashSnglTxn(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthAtmCashSnglTxn) { // not required
		return nil
	}

	if err := validate.Pattern("authAtmCashSnglTxn", "body", string(m.AuthAtmCashSnglTxn), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthAtmOtcRtlFreq(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthAtmOtcRtlFreq) { // not required
		return nil
	}

	if err := validate.MinLength("authAtmOtcRtlFreq", "body", string(*m.AuthAtmOtcRtlFreq), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("authAtmOtcRtlFreq", "body", string(*m.AuthAtmOtcRtlFreq), 1); err != nil {
		return err
	}

	if err := validate.Pattern("authAtmOtcRtlFreq", "body", string(*m.AuthAtmOtcRtlFreq), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthOtcCashAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthOtcCashAmt) { // not required
		return nil
	}

	if err := validate.Pattern("authOtcCashAmt", "body", string(m.AuthOtcCashAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthOtcCashNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthOtcCashNbr) { // not required
		return nil
	}

	if err := validate.Pattern("authOtcCashNbr", "body", string(m.AuthOtcCashNbr), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthOtcCashSngl(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthOtcCashSngl) { // not required
		return nil
	}

	if err := validate.Pattern("authOtcCashSngl", "body", string(m.AuthOtcCashSngl), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthRtlAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthRtlAmt) { // not required
		return nil
	}

	if err := validate.Pattern("authRtlAmt", "body", string(m.AuthRtlAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthRtlNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthRtlNbr) { // not required
		return nil
	}

	if err := validate.Pattern("authRtlNbr", "body", string(m.AuthRtlNbr), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthRtlSnglTxn(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthRtlSnglTxn) { // not required
		return nil
	}

	if err := validate.Pattern("authRtlSnglTxn", "body", string(m.AuthRtlSnglTxn), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthTotalTxnAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthTotalTxnAmt) { // not required
		return nil
	}

	if err := validate.Pattern("authTotalTxnAmt", "body", string(m.AuthTotalTxnAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateAuthTotalTxnNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthTotalTxnNbr) { // not required
		return nil
	}

	if err := validate.Pattern("authTotalTxnNbr", "body", string(m.AuthTotalTxnNbr), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateCardNbr(formats strfmt.Registry) error {

	if err := validate.Required("cardNbr", "body", m.CardNbr); err != nil {
		return err
	}

	if err := validate.MinLength("cardNbr", "body", string(*m.CardNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardNbr", "body", string(*m.CardNbr), 19); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateCardSeq(formats strfmt.Registry) error {

	if swag.IsZero(m.CardSeq) { // not required
		return nil
	}

	if err := validate.MinLength("cardSeq", "body", string(*m.CardSeq), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardSeq", "body", string(*m.CardSeq), 4); err != nil {
		return err
	}

	if err := validate.Pattern("cardSeq", "body", string(*m.CardSeq), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateCardholderFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.CardholderFlag) { // not required
		return nil
	}

	if err := validate.MinLength("cardholderFlag", "body", string(*m.CardholderFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardholderFlag", "body", string(*m.CardholderFlag), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateCity(formats strfmt.Registry) error {

	if swag.IsZero(m.City) { // not required
		return nil
	}

	if err := validate.MinLength("city", "body", string(*m.City), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("city", "body", string(*m.City), 30); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateCommon(formats strfmt.Registry) error {

	if swag.IsZero(m.Common) { // not required
		return nil
	}

	if m.Common != nil {
		if err := m.Common.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("common")
			}
			return err
		}
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateCrdLmtProf(formats strfmt.Registry) error {

	if swag.IsZero(m.CrdLmtProf) { // not required
		return nil
	}

	if err := validate.MinLength("crdLmtProf", "body", string(*m.CrdLmtProf), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("crdLmtProf", "body", string(*m.CrdLmtProf), 3); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateCustomerNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomerNbr) { // not required
		return nil
	}

	if err := validate.MinLength("customerNbr", "body", string(*m.CustomerNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("customerNbr", "body", string(*m.CustomerNbr), 19); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateDisabltyInd(formats strfmt.Registry) error {

	if swag.IsZero(m.DisabltyInd) { // not required
		return nil
	}

	if err := validate.MinLength("disabltyInd", "body", string(*m.DisabltyInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("disabltyInd", "body", string(*m.DisabltyInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateDisabltyInit(formats strfmt.Registry) error {

	if swag.IsZero(m.DisabltyInit) { // not required
		return nil
	}

	if err := validate.MinLength("disabltyInit", "body", string(*m.DisabltyInit), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("disabltyInit", "body", string(*m.DisabltyInit), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEcomAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.EcomAmt) { // not required
		return nil
	}

	if err := validate.Pattern("ecomAmt", "body", string(m.EcomAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEcomAmtAccum(formats strfmt.Registry) error {

	if swag.IsZero(m.EcomAmtAccum) { // not required
		return nil
	}

	if err := validate.Pattern("ecomAmtAccum", "body", string(m.EcomAmtAccum), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEcomNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.EcomNbr) { // not required
		return nil
	}

	if err := validate.Pattern("ecomNbr", "body", string(m.EcomNbr), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEcomNbrAccum(formats strfmt.Registry) error {

	if swag.IsZero(m.EcomNbrAccum) { // not required
		return nil
	}

	if err := validate.Pattern("ecomNbrAccum", "body", string(m.EcomNbrAccum), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEcommRestInd(formats strfmt.Registry) error {

	if swag.IsZero(m.EcommRestInd) { // not required
		return nil
	}

	if err := validate.MinLength("ecommRestInd", "body", string(*m.EcommRestInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ecommRestInd", "body", string(*m.EcommRestInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEmbPinCommPref(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbPinCommPref) { // not required
		return nil
	}

	if err := validate.MinLength("embPinCommPref", "body", string(*m.EmbPinCommPref), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embPinCommPref", "body", string(*m.EmbPinCommPref), 1); err != nil {
		return err
	}

	if err := validate.Pattern("embPinCommPref", "body", string(*m.EmbPinCommPref), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEmbPinCommPrefOvrd(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbPinCommPrefOvrd) { // not required
		return nil
	}

	if err := validate.MinLength("embPinCommPrefOvrd", "body", string(*m.EmbPinCommPrefOvrd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embPinCommPrefOvrd", "body", string(*m.EmbPinCommPrefOvrd), 1); err != nil {
		return err
	}

	if err := validate.Pattern("embPinCommPrefOvrd", "body", string(*m.EmbPinCommPrefOvrd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEmbPinMemWord(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbPinMemWord) { // not required
		return nil
	}

	if err := validate.MinLength("embPinMemWord", "body", string(*m.EmbPinMemWord), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embPinMemWord", "body", string(*m.EmbPinMemWord), 20); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEmbPinMobileNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbPinMobileNbr) { // not required
		return nil
	}

	if err := validate.MinLength("embPinMobileNbr", "body", string(*m.EmbPinMobileNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embPinMobileNbr", "body", string(*m.EmbPinMobileNbr), 20); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEmblmID(formats strfmt.Registry) error {

	if swag.IsZero(m.EmblmID) { // not required
		return nil
	}

	if err := validate.MinLength("emblmId", "body", string(*m.EmblmID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("emblmId", "body", string(*m.EmblmID), 5); err != nil {
		return err
	}

	if err := validate.Pattern("emblmId", "body", string(*m.EmblmID), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEmbossedName1(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbossedName1) { // not required
		return nil
	}

	if err := validate.MinLength("embossedName1", "body", string(*m.EmbossedName1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embossedName1", "body", string(*m.EmbossedName1), 26); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEmbossedName2(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbossedName2) { // not required
		return nil
	}

	if err := validate.MinLength("embossedName2", "body", string(*m.EmbossedName2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embossedName2", "body", string(*m.EmbossedName2), 26); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEmbrName1(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbrName1) { // not required
		return nil
	}

	if err := validate.MinLength("embrName1", "body", string(*m.EmbrName1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embrName1", "body", string(*m.EmbrName1), 40); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateEmbrName2(formats strfmt.Registry) error {

	if swag.IsZero(m.EmbrName2) { // not required
		return nil
	}

	if err := validate.MinLength("embrName2", "body", string(*m.EmbrName2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("embrName2", "body", string(*m.EmbrName2), 40); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateForeignUse(formats strfmt.Registry) error {

	if err := validate.Required("foreignUse", "body", m.ForeignUse); err != nil {
		return err
	}

	if err := validate.MinLength("foreignUse", "body", string(*m.ForeignUse), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("foreignUse", "body", string(*m.ForeignUse), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateInvPinTries(formats strfmt.Registry) error {

	if swag.IsZero(m.InvPinTries) { // not required
		return nil
	}

	if err := validate.MinLength("invPinTries", "body", string(*m.InvPinTries), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("invPinTries", "body", string(*m.InvPinTries), 1); err != nil {
		return err
	}

	if err := validate.Pattern("invPinTries", "body", string(*m.InvPinTries), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateLangCode(formats strfmt.Registry) error {

	if swag.IsZero(m.LangCode) { // not required
		return nil
	}

	if err := validate.MinLength("langCode", "body", string(*m.LangCode), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("langCode", "body", string(*m.LangCode), 3); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateMobDeviceID(formats strfmt.Registry) error {

	if swag.IsZero(m.MobDeviceID) { // not required
		return nil
	}

	if err := validate.MinLength("mobDeviceId", "body", string(*m.MobDeviceID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mobDeviceId", "body", string(*m.MobDeviceID), 20); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateMobProvisionStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.MobProvisionStatus) { // not required
		return nil
	}

	if err := validate.MinLength("mobProvisionStatus", "body", string(*m.MobProvisionStatus), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("mobProvisionStatus", "body", string(*m.MobProvisionStatus), 1); err != nil {
		return err
	}

	if err := validate.Pattern("mobProvisionStatus", "body", string(*m.MobProvisionStatus), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateMotoRestFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.MotoRestFlag) { // not required
		return nil
	}

	if err := validate.MinLength("motoRestFlag", "body", string(*m.MotoRestFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("motoRestFlag", "body", string(*m.MotoRestFlag), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateOvrsRestriction(formats strfmt.Registry) error {

	if swag.IsZero(m.OvrsRestriction) { // not required
		return nil
	}

	if err := validate.MinLength("ovrsRestriction", "body", string(*m.OvrsRestriction), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("ovrsRestriction", "body", string(*m.OvrsRestriction), 1); err != nil {
		return err
	}

	if err := validate.Pattern("ovrsRestriction", "body", string(*m.OvrsRestriction), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validatePlasticID(formats strfmt.Registry) error {

	if swag.IsZero(m.PlasticID) { // not required
		return nil
	}

	if err := validate.MinLength("plasticId", "body", string(*m.PlasticID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("plasticId", "body", string(*m.PlasticID), 10); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validatePosRestFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.PosRestFlag) { // not required
		return nil
	}

	if err := validate.MinLength("posRestFlag", "body", string(*m.PosRestFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("posRestFlag", "body", string(*m.PosRestFlag), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validatePostCdRestr(formats strfmt.Registry) error {

	if swag.IsZero(m.PostCdRestr) { // not required
		return nil
	}

	if err := validate.MinLength("postCdRestr", "body", string(*m.PostCdRestr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("postCdRestr", "body", string(*m.PostCdRestr), 1); err != nil {
		return err
	}

	if err := validate.Pattern("postCdRestr", "body", string(*m.PostCdRestr), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateProgramID(formats strfmt.Registry) error {

	if swag.IsZero(m.ProgramID) { // not required
		return nil
	}

	if err := validate.MinLength("programId", "body", string(*m.ProgramID), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("programId", "body", string(*m.ProgramID), 8); err != nil {
		return err
	}

	if err := validate.Pattern("programId", "body", string(*m.ProgramID), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validatePstlCd(formats strfmt.Registry) error {

	if swag.IsZero(m.PstlCd) { // not required
		return nil
	}

	if err := validate.MinLength("pstlCd", "body", string(*m.PstlCd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("pstlCd", "body", string(*m.PstlCd), 10); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateQuasiCashAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.QuasiCashAmt) { // not required
		return nil
	}

	if err := validate.Pattern("quasiCashAmt", "body", string(m.QuasiCashAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateQuasiCashLimit(formats strfmt.Registry) error {

	if swag.IsZero(m.QuasiCashLimit) { // not required
		return nil
	}

	if err := validate.Pattern("quasiCashLimit", "body", string(m.QuasiCashLimit), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateQuasiCashNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.QuasiCashNbr) { // not required
		return nil
	}

	if err := validate.Pattern("quasiCashNbr", "body", string(m.QuasiCashNbr), `^(-)?[0-9]{1,9}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateRqtdCardType(formats strfmt.Registry) error {

	if swag.IsZero(m.RqtdCardType) { // not required
		return nil
	}

	if err := validate.MinLength("rqtdCardType", "body", string(*m.RqtdCardType), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("rqtdCardType", "body", string(*m.RqtdCardType), 2); err != nil {
		return err
	}

	if err := validate.Pattern("rqtdCardType", "body", string(*m.RqtdCardType), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateStProvince(formats strfmt.Registry) error {

	if swag.IsZero(m.StProvince) { // not required
		return nil
	}

	if err := validate.MinLength("stProvince", "body", string(*m.StProvince), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("stProvince", "body", string(*m.StProvince), 3); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateTxnLimitEcom(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnLimitEcom) { // not required
		return nil
	}

	if err := validate.Pattern("txnLimitEcom", "body", string(m.TxnLimitEcom), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateTypeCardMailer(formats strfmt.Registry) error {

	if swag.IsZero(m.TypeCardMailer) { // not required
		return nil
	}

	if err := validate.MinLength("typeCardMailer", "body", string(*m.TypeCardMailer), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("typeCardMailer", "body", string(*m.TypeCardMailer), 2); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateTypeOfCard(formats strfmt.Registry) error {

	if swag.IsZero(m.TypeOfCard) { // not required
		return nil
	}

	if err := validate.MinLength("typeOfCard", "body", string(*m.TypeOfCard), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("typeOfCard", "body", string(*m.TypeOfCard), 2); err != nil {
		return err
	}

	if err := validate.Pattern("typeOfCard", "body", string(*m.TypeOfCard), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser1(formats strfmt.Registry) error {

	if swag.IsZero(m.User1) { // not required
		return nil
	}

	if err := validate.MinLength("user1", "body", string(*m.User1), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user1", "body", string(*m.User1), 20); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser10(formats strfmt.Registry) error {

	if swag.IsZero(m.User10) { // not required
		return nil
	}

	if err := validate.MinLength("user10", "body", string(*m.User10), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user10", "body", string(*m.User10), 20); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser2(formats strfmt.Registry) error {

	if swag.IsZero(m.User2) { // not required
		return nil
	}

	if err := validate.MinLength("user2", "body", string(*m.User2), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user2", "body", string(*m.User2), 20); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser3(formats strfmt.Registry) error {

	if swag.IsZero(m.User3) { // not required
		return nil
	}

	if err := validate.MinLength("user3", "body", string(*m.User3), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user3", "body", string(*m.User3), 19); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser4(formats strfmt.Registry) error {

	if swag.IsZero(m.User4) { // not required
		return nil
	}

	if err := validate.MinLength("user4", "body", string(*m.User4), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user4", "body", string(*m.User4), 4); err != nil {
		return err
	}

	if err := validate.Pattern("user4", "body", string(*m.User4), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser5(formats strfmt.Registry) error {

	if swag.IsZero(m.User5) { // not required
		return nil
	}

	if err := validate.MinLength("user5", "body", string(*m.User5), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user5", "body", string(*m.User5), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser6(formats strfmt.Registry) error {

	if swag.IsZero(m.User6) { // not required
		return nil
	}

	if err := validate.MinLength("user6", "body", string(*m.User6), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user6", "body", string(*m.User6), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser7(formats strfmt.Registry) error {

	if swag.IsZero(m.User7) { // not required
		return nil
	}

	if err := validate.MinLength("user7", "body", string(*m.User7), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user7", "body", string(*m.User7), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser8(formats strfmt.Registry) error {

	if swag.IsZero(m.User8) { // not required
		return nil
	}

	if err := validate.MinLength("user8", "body", string(*m.User8), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user8", "body", string(*m.User8), 1); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUser9(formats strfmt.Registry) error {

	if swag.IsZero(m.User9) { // not required
		return nil
	}

	if err := validate.MinLength("user9", "body", string(*m.User9), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("user9", "body", string(*m.User9), 19); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUsrAmtLim(formats strfmt.Registry) error {

	if swag.IsZero(m.UsrAmtLim) { // not required
		return nil
	}

	if err := validate.Pattern("usrAmtLim", "body", string(m.UsrAmtLim), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *EmbosserUpdateRequest) validateUsrExpDate(formats strfmt.Registry) error {

	if swag.IsZero(m.UsrExpDate) { // not required
		return nil
	}

	if err := validate.Pattern("usrExpDate", "body", string(m.UsrExpDate), `^(-)?[0-9]{1,7}$`); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EmbosserUpdateRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EmbosserUpdateRequest) UnmarshalBinary(b []byte) error {
	var res EmbosserUpdateRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
