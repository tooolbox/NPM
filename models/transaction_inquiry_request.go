// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionInquiryRequest transaction inquiry request
//
// swagger:model TransactionInquiryRequest
type TransactionInquiryRequest struct {

	//  Max length = 19, Account Number: Number of Customer's account. Must be numeric and greater than zero. This can be either Account number or Card number. Enter an account or card number to search for a match on either the Embosser record or the Account Base Segment record
	// Required: true
	// Max Length: 19
	// Min Length: 0
	Account *string `json:"account"`

	//  Max length = 19, Card Number: Unique Card number embossed on the plastic card. 1. Must be numeric and greater than 0 2. Card number must be on file 3. Card number must be valid for the Organisation value provided
	// Max Length: 19
	// Min Length: 0
	CardNbr *string `json:"cardNbr,omitempty"`

	//  Max length = 5, Card Sequence Number: Identification number assigned to Embosser record to distinguish between multiple cards issued with the same card. 1. Must be numeric and greater than 0 if provided 2. Must be between 0 and 99 if smart card 3. If not provided, and not a smart card, default to value of 0001
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CardSeq *string `json:"cardSeq,omitempty"`

	// common
	Common *Header `json:"common,omitempty"`

	//  Max length = 1, Transaction Detail flag: Parameter to define period of returned transactions.  Valid values are C, R, M, B  and Space: C = CURRENT- Cycle to Date R = RECENT- Statemented M = MONTH- Statemented transaction of specific month. B = BOTH- Cycle to date and Statemented,.  If this field is left blank/space, default is 'B'.
	// Max Length: 1
	// Min Length: 0
	DetailFlag *string `json:"detailFlag,omitempty"`

	//  Max length = 1, Dual Currency Indicator. Valid values are :  F - Foreign Account L - Local Account
	// Max Length: 1
	// Min Length: 0
	ForeignUse *string `json:"foreignUse,omitempty"`

	//  Max length = 17, Transaction amount range. This field indicates the 'from' amount. Any valid amount range or low values to be entered. Zero is a valid value and the service will try to fetch the transactions based on the value entered.
	// Pattern: ^(-)?[0-9]{1,17}$
	FromAmt string `json:"fromAmt,omitempty"`

	// Format: YYYYDDD. Transaction Date Range. This field indicates 'from' date of the transacation.
	// Max Length: 7
	// Min Length: 0
	// Pattern: ^[0-9]*$
	FromDate *string `json:"fromDate,omitempty"`

	//  Max length = 20, Keyword of the transaction.
	// Max Length: 20
	// Min Length: 0
	Keyword *string `json:"keyword,omitempty"`

	//  Max length = 3, Logic module. When provided the responses will contain only the transactions associated with the logic module.
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	LogicModule *string `json:"logicModule,omitempty"`

	//  Max length = 1, Merchant information indicator. Values are: 0 - Merchant information is not required 1 - Merchant information is required.
	// Max Length: 1
	// Min Length: 0
	MerchInfoInd *string `json:"merchInfoInd,omitempty"`

	//  Max length = 2, Number of transaction to be retrieved. Maximum number is 50.
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	NumTxns *string `json:"numTxns,omitempty"`

	//  Max length = 1, Recurring transaction indicator. Values are:  0 - Do not return recurring transactions 1 - Return recurring transactions.
	// Max Length: 1
	// Min Length: 0
	RecurInfoInd *string `json:"recurInfoInd,omitempty"`

	//  Max length = 17, Transaction amount range. This field indicates the 'to' amount. Any valid amount range or low values to be entered. Zero is a valid value and the service will try to fetch the transactions based on the value entered.
	// Pattern: ^(-)?[0-9]{1,17}$
	ToAmt string `json:"toAmt,omitempty"`

	// Format: YYYYDDD. Transaction Date Range. This field indicates 'to' date of the transacation.
	// Max Length: 7
	// Min Length: 0
	// Pattern: ^[0-9]*$
	ToDate *string `json:"toDate,omitempty"`

	//  Max length = 1, Transaction File Type. Associated with the page scroll and to be populated from the previous response values. Values are:  C - Use current statement L - Use large statement file S - Use small statement file.
	// Max Length: 1
	// Min Length: 0
	TxnFileType *string `json:"txnFileType,omitempty"`

	//  Max length = 2, Transaction Month number:  Statement Month Number to be  provided if TXN-DETAIL is 'M'. Relative statement number can be used if the actual statement dates are not known, i.e. : 00 - Current statement01 - Previous months statement. 02 - Second previous months statement, etc.
	// Max Length: 2
	// Min Length: 0
	TxnNbrMonths *string `json:"txnNbrMonths,omitempty"`

	//  Max length = 23, Transaction reference number. Transaction details returned only for the transaction reference number given in the input.
	// Max Length: 23
	// Min Length: 0
	TxnRefNbr *string `json:"txnRefNbr,omitempty"`

	// Format: YYYYDDD. Transaction start date. Associated with the page scroll and to be populated from the previous response values. For internal use only.
	// Pattern: ^(-)?[0-9]{1,7}$
	TxnStartDate string `json:"txnStartDate,omitempty"`

	//  Max length = 5, Transaction Sequence Number. Associated with the page scroll and to be populated from the previous response values. For internal use only.
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	TxnStartNum *string `json:"txnStartNum,omitempty"`

	//  Max length = 1, Transaction Type. Valid values are:  0 - All 1 - Interest and fee 2 - Payment 3 - Dispute 4 - Warehouse 5 - Interest only 6 - Fee only 7 - Card only 8 - All but interest, fee, and memo transactions.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	TxnType *string `json:"txnType,omitempty"`
}

// Validate validates this transaction inquiry request
func (m *TransactionInquiryRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardSeq(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDetailFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForeignUse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFromAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFromDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogicModule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMerchInfoInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumTxns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurInfoInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToAmt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnFileType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnNbrMonths(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnRefNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnStartNum(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionInquiryRequest) validateAccount(formats strfmt.Registry) error {

	if err := validate.Required("account", "body", m.Account); err != nil {
		return err
	}

	if err := validate.MinLength("account", "body", string(*m.Account), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("account", "body", string(*m.Account), 19); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateCardNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.CardNbr) { // not required
		return nil
	}

	if err := validate.MinLength("cardNbr", "body", string(*m.CardNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardNbr", "body", string(*m.CardNbr), 19); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateCardSeq(formats strfmt.Registry) error {

	if swag.IsZero(m.CardSeq) { // not required
		return nil
	}

	if err := validate.MinLength("cardSeq", "body", string(*m.CardSeq), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardSeq", "body", string(*m.CardSeq), 5); err != nil {
		return err
	}

	if err := validate.Pattern("cardSeq", "body", string(*m.CardSeq), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateCommon(formats strfmt.Registry) error {

	if swag.IsZero(m.Common) { // not required
		return nil
	}

	if m.Common != nil {
		if err := m.Common.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("common")
			}
			return err
		}
	}

	return nil
}

func (m *TransactionInquiryRequest) validateDetailFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.DetailFlag) { // not required
		return nil
	}

	if err := validate.MinLength("detailFlag", "body", string(*m.DetailFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("detailFlag", "body", string(*m.DetailFlag), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateForeignUse(formats strfmt.Registry) error {

	if swag.IsZero(m.ForeignUse) { // not required
		return nil
	}

	if err := validate.MinLength("foreignUse", "body", string(*m.ForeignUse), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("foreignUse", "body", string(*m.ForeignUse), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateFromAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.FromAmt) { // not required
		return nil
	}

	if err := validate.Pattern("fromAmt", "body", string(m.FromAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateFromDate(formats strfmt.Registry) error {

	if swag.IsZero(m.FromDate) { // not required
		return nil
	}

	if err := validate.MinLength("fromDate", "body", string(*m.FromDate), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("fromDate", "body", string(*m.FromDate), 7); err != nil {
		return err
	}

	if err := validate.Pattern("fromDate", "body", string(*m.FromDate), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateKeyword(formats strfmt.Registry) error {

	if swag.IsZero(m.Keyword) { // not required
		return nil
	}

	if err := validate.MinLength("keyword", "body", string(*m.Keyword), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("keyword", "body", string(*m.Keyword), 20); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateLogicModule(formats strfmt.Registry) error {

	if swag.IsZero(m.LogicModule) { // not required
		return nil
	}

	if err := validate.MinLength("logicModule", "body", string(*m.LogicModule), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("logicModule", "body", string(*m.LogicModule), 3); err != nil {
		return err
	}

	if err := validate.Pattern("logicModule", "body", string(*m.LogicModule), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateMerchInfoInd(formats strfmt.Registry) error {

	if swag.IsZero(m.MerchInfoInd) { // not required
		return nil
	}

	if err := validate.MinLength("merchInfoInd", "body", string(*m.MerchInfoInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("merchInfoInd", "body", string(*m.MerchInfoInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateNumTxns(formats strfmt.Registry) error {

	if swag.IsZero(m.NumTxns) { // not required
		return nil
	}

	if err := validate.MinLength("numTxns", "body", string(*m.NumTxns), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("numTxns", "body", string(*m.NumTxns), 2); err != nil {
		return err
	}

	if err := validate.Pattern("numTxns", "body", string(*m.NumTxns), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateRecurInfoInd(formats strfmt.Registry) error {

	if swag.IsZero(m.RecurInfoInd) { // not required
		return nil
	}

	if err := validate.MinLength("recurInfoInd", "body", string(*m.RecurInfoInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("recurInfoInd", "body", string(*m.RecurInfoInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateToAmt(formats strfmt.Registry) error {

	if swag.IsZero(m.ToAmt) { // not required
		return nil
	}

	if err := validate.Pattern("toAmt", "body", string(m.ToAmt), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateToDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ToDate) { // not required
		return nil
	}

	if err := validate.MinLength("toDate", "body", string(*m.ToDate), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("toDate", "body", string(*m.ToDate), 7); err != nil {
		return err
	}

	if err := validate.Pattern("toDate", "body", string(*m.ToDate), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateTxnFileType(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnFileType) { // not required
		return nil
	}

	if err := validate.MinLength("txnFileType", "body", string(*m.TxnFileType), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnFileType", "body", string(*m.TxnFileType), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateTxnNbrMonths(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnNbrMonths) { // not required
		return nil
	}

	if err := validate.MinLength("txnNbrMonths", "body", string(*m.TxnNbrMonths), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnNbrMonths", "body", string(*m.TxnNbrMonths), 2); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateTxnRefNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnRefNbr) { // not required
		return nil
	}

	if err := validate.MinLength("txnRefNbr", "body", string(*m.TxnRefNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnRefNbr", "body", string(*m.TxnRefNbr), 23); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateTxnStartDate(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnStartDate) { // not required
		return nil
	}

	if err := validate.Pattern("txnStartDate", "body", string(m.TxnStartDate), `^(-)?[0-9]{1,7}$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateTxnStartNum(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnStartNum) { // not required
		return nil
	}

	if err := validate.MinLength("txnStartNum", "body", string(*m.TxnStartNum), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnStartNum", "body", string(*m.TxnStartNum), 5); err != nil {
		return err
	}

	if err := validate.Pattern("txnStartNum", "body", string(*m.TxnStartNum), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest) validateTxnType(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnType) { // not required
		return nil
	}

	if err := validate.MinLength("txnType", "body", string(*m.TxnType), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnType", "body", string(*m.TxnType), 1); err != nil {
		return err
	}

	if err := validate.Pattern("txnType", "body", string(*m.TxnType), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionInquiryRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionInquiryRequest) UnmarshalBinary(b []byte) error {
	var res TransactionInquiryRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
