// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionInquiryRequest2 transaction inquiry request2
//
// swagger:model TransactionInquiryRequest2
type TransactionInquiryRequest2 struct {

	//  Max length = 19, Account Number: Number of Customer's account. Must be numeric and greater than zero. This can be either Account number or Card number. Enter an account or card number to search for a match on either the Embosser record or the Account Base Segment record
	// Required: true
	// Max Length: 19
	// Min Length: 0
	Acct *string `json:"acct"`

	//  Max length = 23, Interchange Reference Number
	// Max Length: 23
	// Min Length: 0
	ArnRefNbr *string `json:"arnRefNbr,omitempty"`

	//  Max length = 19, Card Number: Unique Card number embossed on the plastic card. 1. Must be numeric and greater than 0 2. Card number must be on file 3. Card number must be valid for the organization value provided
	// Max Length: 19
	// Min Length: 0
	CardNbr *string `json:"cardNbr,omitempty"`

	//  Max length = 5, Card Sequence Number: Identification number assigned to Embosser record to distinguish between multiple cards issued with the same card. 1. Must be numeric and greater than 0 if provided 2. Must be between 0 and 99 if smart card 3. If not provided, and not a smart card, default to value of 0001
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	CardSeq *string `json:"cardSeq,omitempty"`

	// common
	Common *Header `json:"common,omitempty"`

	//  Max length = 5, Default Equal Payment Plan number
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	DefaultEppPlan *string `json:"defaultEppPlan,omitempty"`

	//  Max length = 1, Equal Payment Plan indicator
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	EppInd *string `json:"eppInd,omitempty"`

	//  Max length = 1, Dual Currency Indicator. Valid values are <UL><LI><EM> 0 -</EM> Local </LI><LI><EM>1 -</EM> Foreign </LI></UL>
	// Max Length: 1
	// Min Length: 0
	ForeignUse *string `json:"foreignUse,omitempty"`

	//  Max length = 20, Keyword of the transaction.
	// Max Length: 20
	// Min Length: 0
	Keyword *string `json:"keyword,omitempty"`

	//  Max length = 3, Logic module. When provided the responses will contain only the transactions associated with the logic module.
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	Lm *string `json:"lm,omitempty"`

	//  Max length = 1, Merchant information indicator. Values are: 0 - Merchant information is not required 1 - Merchant information is required.
	// Max Length: 1
	// Min Length: 0
	MerchInfoInd *string `json:"merchInfoInd,omitempty"`

	//  Max length = 2, Number of transaction to be retrieved. Maximum number is 50.
	// Max Length: 2
	// Min Length: 0
	// Pattern: ^[0-9]*$
	NumberTxns *string `json:"numberTxns,omitempty"`

	//  Max length = 1, This field is used to enable the billing account processing. Valid values are <UL><LI><EM>0 -</EM> Process Normal Accounts </LI><LI><EM>1 -</EM> Process Sub Accounts </LI></UL>
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	ProcBillAcct *string `json:"procBillAcct,omitempty"`

	//  Max length = 1, Recurring transaction indicator. Values are:  0 - Do not return recurring transactions 1 - Return recurring transactions.
	// Max Length: 1
	// Min Length: 0
	RecurInfoInd *string `json:"recurInfoInd,omitempty"`

	//  Max length = 1, Transaction Start File Type. Associated with the page scroll and to be populated from the previous response values. Values are:  C - Use current statement L - Use large statement file S - Use small statement file.
	// Max Length: 1
	// Min Length: 0
	StartFileType *string `json:"startFileType,omitempty"`

	//  Max length = 5, Transaction Start Sequence Number. Associated with the page scroll and to be populated from the previous response values.
	// Max Length: 5
	// Min Length: 0
	// Pattern: ^[0-9]*$
	StartSeqNbr *string `json:"startSeqNbr,omitempty"`

	// Format: YYYYMMDD. Transaction Start Statement Date. Associated with the page scroll and to be populated from the previous response values.
	StartStmtDate string `json:"startStmtDate,omitempty"`

	//  Max length = 3, This field is used to return the index of last sub account processed. For Normal accounts index will be zero.
	// Max Length: 3
	// Min Length: 0
	// Pattern: ^[0-9]*$
	SubAcctIdx *string `json:"subAcctIdx,omitempty"`

	//  Max length = 1, Request to return suppressed transactions as well as normal transactions
	// Max Length: 1
	// Min Length: 0
	TransSuppressFlag *string `json:"transSuppressFlag,omitempty"`

	//  Max length = 17, Transaction amount range. This field indicates the 'from' amount. Any valid amount range or low values to be entered. Zero is a valid value and the service will try to fetch the transactions based on the value entered.
	// Pattern: ^(-)?[0-9]{1,17}$
	TxnAmtFrom string `json:"txnAmtFrom,omitempty"`

	//  Max length = 17, Transaction amount range. This field indicates the 'to' amount. Any valid amount range or low values to be entered. Zero is a valid value and the service will try to fetch the transactions based on the value entered.
	// Pattern: ^(-)?[0-9]{1,17}$
	TxnAmtThru string `json:"txnAmtThru,omitempty"`

	//  Max length = 1, Transaction Currency Indicator. Valid values are <UL><LI><EM> 0 -</EM> All </LI><LI><EM>1 -</EM> Local </LI><LI><EM>2 -</EM> Foreign </LI></UL>
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	TxnCurrInd *string `json:"txnCurrInd,omitempty"`

	// Format: YYYYMMDD. Transaction Date Range. This field indicates 'from' date of the transacation.
	TxnDateFrom string `json:"txnDateFrom,omitempty"`

	//  Max length = 1, Transaction Date selector. Valid values are <UL><LI><EM> E -</EM> Effective Date / Transaction Date </LI><LI><EM>P -</EM> Posting Date </LI></UL>
	// Required: true
	// Max Length: 1
	// Min Length: 0
	TxnDateSel *string `json:"txnDateSel"`

	// Format: YYYYMMDD. Transaction Date Range. This field indicates 'to' date of the transacation.
	TxnDateThru string `json:"txnDateThru,omitempty"`

	//  Max length = 1, Transaction Detail flag: Parameter to define period of returned transactions.  Valid values are C, R, M, B  and Space: C = CURRENT- Cycle to Date R = RECENT- Statemented M = MONTH- Statemented transaction of specific month. B = BOTH- Cycle to date and Statemented,.  If this field is left blank/space, default is 'B'.
	// Max Length: 1
	// Min Length: 0
	TxnDetail *string `json:"txnDetail,omitempty"`

	//  Max length = 2, Transaction Month number:  Statement Month Number to be  provided if TXN-DETAIL is 'M'. Relative statement number can be used if the actual statement dates are not known, i.e. : 00 - Current statement01 - Previous months statement. 02 - Second previous months statement, etc.
	// Max Length: 2
	// Min Length: 0
	TxnNbrMonths *string `json:"txnNbrMonths,omitempty"`

	//  Max length = 23, Transaction reference number. Transaction details returned only for the transaction reference number given in the input.
	// Max Length: 23
	// Min Length: 0
	TxnRefNbr *string `json:"txnRefNbr,omitempty"`

	//  Max length = 1, Transaction Type. Valid values are:  0 - All 1 - Interest and fee 2 - Payment 3 - Dispute 4 - Warehouse 5 - Interest only 6 - Fee only 7 - Card only 8 - All but interest, fee, and memo transactions.
	// Max Length: 1
	// Min Length: 0
	// Pattern: ^[0-9]*$
	TxnType *string `json:"txnType,omitempty"`
}

// Validate validates this transaction inquiry request2
func (m *TransactionInquiryRequest2) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAcct(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArnRefNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCardSeq(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDefaultEppPlan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEppInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForeignUse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMerchInfoInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumberTxns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcBillAcct(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecurInfoInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartFileType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartSeqNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubAcctIdx(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransSuppressFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnAmtFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnAmtThru(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnCurrInd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnDateSel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnDetail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnNbrMonths(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnRefNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxnType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionInquiryRequest2) validateAcct(formats strfmt.Registry) error {

	if err := validate.Required("acct", "body", m.Acct); err != nil {
		return err
	}

	if err := validate.MinLength("acct", "body", string(*m.Acct), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("acct", "body", string(*m.Acct), 19); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateArnRefNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.ArnRefNbr) { // not required
		return nil
	}

	if err := validate.MinLength("arnRefNbr", "body", string(*m.ArnRefNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("arnRefNbr", "body", string(*m.ArnRefNbr), 23); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateCardNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.CardNbr) { // not required
		return nil
	}

	if err := validate.MinLength("cardNbr", "body", string(*m.CardNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardNbr", "body", string(*m.CardNbr), 19); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateCardSeq(formats strfmt.Registry) error {

	if swag.IsZero(m.CardSeq) { // not required
		return nil
	}

	if err := validate.MinLength("cardSeq", "body", string(*m.CardSeq), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("cardSeq", "body", string(*m.CardSeq), 5); err != nil {
		return err
	}

	if err := validate.Pattern("cardSeq", "body", string(*m.CardSeq), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateCommon(formats strfmt.Registry) error {

	if swag.IsZero(m.Common) { // not required
		return nil
	}

	if m.Common != nil {
		if err := m.Common.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("common")
			}
			return err
		}
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateDefaultEppPlan(formats strfmt.Registry) error {

	if swag.IsZero(m.DefaultEppPlan) { // not required
		return nil
	}

	if err := validate.MinLength("defaultEppPlan", "body", string(*m.DefaultEppPlan), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("defaultEppPlan", "body", string(*m.DefaultEppPlan), 5); err != nil {
		return err
	}

	if err := validate.Pattern("defaultEppPlan", "body", string(*m.DefaultEppPlan), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateEppInd(formats strfmt.Registry) error {

	if swag.IsZero(m.EppInd) { // not required
		return nil
	}

	if err := validate.MinLength("eppInd", "body", string(*m.EppInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("eppInd", "body", string(*m.EppInd), 1); err != nil {
		return err
	}

	if err := validate.Pattern("eppInd", "body", string(*m.EppInd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateForeignUse(formats strfmt.Registry) error {

	if swag.IsZero(m.ForeignUse) { // not required
		return nil
	}

	if err := validate.MinLength("foreignUse", "body", string(*m.ForeignUse), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("foreignUse", "body", string(*m.ForeignUse), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateKeyword(formats strfmt.Registry) error {

	if swag.IsZero(m.Keyword) { // not required
		return nil
	}

	if err := validate.MinLength("keyword", "body", string(*m.Keyword), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("keyword", "body", string(*m.Keyword), 20); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateLm(formats strfmt.Registry) error {

	if swag.IsZero(m.Lm) { // not required
		return nil
	}

	if err := validate.MinLength("lm", "body", string(*m.Lm), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("lm", "body", string(*m.Lm), 3); err != nil {
		return err
	}

	if err := validate.Pattern("lm", "body", string(*m.Lm), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateMerchInfoInd(formats strfmt.Registry) error {

	if swag.IsZero(m.MerchInfoInd) { // not required
		return nil
	}

	if err := validate.MinLength("merchInfoInd", "body", string(*m.MerchInfoInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("merchInfoInd", "body", string(*m.MerchInfoInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateNumberTxns(formats strfmt.Registry) error {

	if swag.IsZero(m.NumberTxns) { // not required
		return nil
	}

	if err := validate.MinLength("numberTxns", "body", string(*m.NumberTxns), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("numberTxns", "body", string(*m.NumberTxns), 2); err != nil {
		return err
	}

	if err := validate.Pattern("numberTxns", "body", string(*m.NumberTxns), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateProcBillAcct(formats strfmt.Registry) error {

	if swag.IsZero(m.ProcBillAcct) { // not required
		return nil
	}

	if err := validate.MinLength("procBillAcct", "body", string(*m.ProcBillAcct), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("procBillAcct", "body", string(*m.ProcBillAcct), 1); err != nil {
		return err
	}

	if err := validate.Pattern("procBillAcct", "body", string(*m.ProcBillAcct), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateRecurInfoInd(formats strfmt.Registry) error {

	if swag.IsZero(m.RecurInfoInd) { // not required
		return nil
	}

	if err := validate.MinLength("recurInfoInd", "body", string(*m.RecurInfoInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("recurInfoInd", "body", string(*m.RecurInfoInd), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateStartFileType(formats strfmt.Registry) error {

	if swag.IsZero(m.StartFileType) { // not required
		return nil
	}

	if err := validate.MinLength("startFileType", "body", string(*m.StartFileType), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("startFileType", "body", string(*m.StartFileType), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateStartSeqNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.StartSeqNbr) { // not required
		return nil
	}

	if err := validate.MinLength("startSeqNbr", "body", string(*m.StartSeqNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("startSeqNbr", "body", string(*m.StartSeqNbr), 5); err != nil {
		return err
	}

	if err := validate.Pattern("startSeqNbr", "body", string(*m.StartSeqNbr), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateSubAcctIdx(formats strfmt.Registry) error {

	if swag.IsZero(m.SubAcctIdx) { // not required
		return nil
	}

	if err := validate.MinLength("subAcctIdx", "body", string(*m.SubAcctIdx), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("subAcctIdx", "body", string(*m.SubAcctIdx), 3); err != nil {
		return err
	}

	if err := validate.Pattern("subAcctIdx", "body", string(*m.SubAcctIdx), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateTransSuppressFlag(formats strfmt.Registry) error {

	if swag.IsZero(m.TransSuppressFlag) { // not required
		return nil
	}

	if err := validate.MinLength("transSuppressFlag", "body", string(*m.TransSuppressFlag), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("transSuppressFlag", "body", string(*m.TransSuppressFlag), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateTxnAmtFrom(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnAmtFrom) { // not required
		return nil
	}

	if err := validate.Pattern("txnAmtFrom", "body", string(m.TxnAmtFrom), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateTxnAmtThru(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnAmtThru) { // not required
		return nil
	}

	if err := validate.Pattern("txnAmtThru", "body", string(m.TxnAmtThru), `^(-)?[0-9]{1,17}$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateTxnCurrInd(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnCurrInd) { // not required
		return nil
	}

	if err := validate.MinLength("txnCurrInd", "body", string(*m.TxnCurrInd), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnCurrInd", "body", string(*m.TxnCurrInd), 1); err != nil {
		return err
	}

	if err := validate.Pattern("txnCurrInd", "body", string(*m.TxnCurrInd), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateTxnDateSel(formats strfmt.Registry) error {

	if err := validate.Required("txnDateSel", "body", m.TxnDateSel); err != nil {
		return err
	}

	if err := validate.MinLength("txnDateSel", "body", string(*m.TxnDateSel), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnDateSel", "body", string(*m.TxnDateSel), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateTxnDetail(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnDetail) { // not required
		return nil
	}

	if err := validate.MinLength("txnDetail", "body", string(*m.TxnDetail), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnDetail", "body", string(*m.TxnDetail), 1); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateTxnNbrMonths(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnNbrMonths) { // not required
		return nil
	}

	if err := validate.MinLength("txnNbrMonths", "body", string(*m.TxnNbrMonths), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnNbrMonths", "body", string(*m.TxnNbrMonths), 2); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateTxnRefNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnRefNbr) { // not required
		return nil
	}

	if err := validate.MinLength("txnRefNbr", "body", string(*m.TxnRefNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnRefNbr", "body", string(*m.TxnRefNbr), 23); err != nil {
		return err
	}

	return nil
}

func (m *TransactionInquiryRequest2) validateTxnType(formats strfmt.Registry) error {

	if swag.IsZero(m.TxnType) { // not required
		return nil
	}

	if err := validate.MinLength("txnType", "body", string(*m.TxnType), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("txnType", "body", string(*m.TxnType), 1); err != nil {
		return err
	}

	if err := validate.Pattern("txnType", "body", string(*m.TxnType), `^[0-9]*$`); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionInquiryRequest2) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionInquiryRequest2) UnmarshalBinary(b []byte) error {
	var res TransactionInquiryRequest2
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
