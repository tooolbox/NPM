// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InsuranceProductTableForCustomerAccountEmbosserAdd1 insurance product table for customer account embosser add1
//
// swagger:model InsuranceProductTableForCustomerAccountEmbosserAdd1
type InsuranceProductTableForCustomerAccountEmbosserAdd1 struct {

	// Format: YYYYMMDD. Effective date of the insurance product. This date may be a future date. CMS assesses the first insurance premium in the cycle that this date occurs. Even if you backdate this field to a date in a previous cycle, CMS calculates insurance charges for the current cycle only. If no entry is made to the Insurance EffectiveDate field when the insurance product is added to the account, CMS assigns the Organisation's next processing date to the field
	EffectiveDate string `json:"effectiveDate,omitempty"`

	//  Max length = 1, Insurance Channel
	// Max Length: 1
	// Min Length: 0
	InsChannel *string `json:"insChannel,omitempty"`

	//  Max length = 18, Insurance Policy reference number
	// Max Length: 18
	// Min Length: 0
	InsPolRefNbr *string `json:"insPolRefNbr,omitempty"`

	//  Max length = 2, Insurance product as defined on the Insurance Product table
	// Max Length: 2
	// Min Length: 0
	InsProduct *string `json:"insProduct,omitempty"`

	// Format: YYYYMMDD. Insurance Sold date
	InsSalesDate string `json:"insSalesDate,omitempty"`
}

// Validate validates this insurance product table for customer account embosser add1
func (m *InsuranceProductTableForCustomerAccountEmbosserAdd1) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInsChannel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInsPolRefNbr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInsProduct(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InsuranceProductTableForCustomerAccountEmbosserAdd1) validateInsChannel(formats strfmt.Registry) error {

	if swag.IsZero(m.InsChannel) { // not required
		return nil
	}

	if err := validate.MinLength("insChannel", "body", string(*m.InsChannel), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("insChannel", "body", string(*m.InsChannel), 1); err != nil {
		return err
	}

	return nil
}

func (m *InsuranceProductTableForCustomerAccountEmbosserAdd1) validateInsPolRefNbr(formats strfmt.Registry) error {

	if swag.IsZero(m.InsPolRefNbr) { // not required
		return nil
	}

	if err := validate.MinLength("insPolRefNbr", "body", string(*m.InsPolRefNbr), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("insPolRefNbr", "body", string(*m.InsPolRefNbr), 18); err != nil {
		return err
	}

	return nil
}

func (m *InsuranceProductTableForCustomerAccountEmbosserAdd1) validateInsProduct(formats strfmt.Registry) error {

	if swag.IsZero(m.InsProduct) { // not required
		return nil
	}

	if err := validate.MinLength("insProduct", "body", string(*m.InsProduct), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("insProduct", "body", string(*m.InsProduct), 2); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InsuranceProductTableForCustomerAccountEmbosserAdd1) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InsuranceProductTableForCustomerAccountEmbosserAdd1) UnmarshalBinary(b []byte) error {
	var res InsuranceProductTableForCustomerAccountEmbosserAdd1
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
